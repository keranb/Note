# 第二章 设备初始化及激活进程0

## 设置根设备，硬盘

内核首先初始化跟设备和硬盘，用bootsect中写入机器系统数据0x901FC的根设备为软盘的信息，设置软盘为根设备，并用起始自0x90080的32字节的机器系统数据的硬盘参数表设置内核中的硬盘信息drive_info。

```c
#define EXT_MEM_K (*(unsigned short *)0x90002)
#define DRIVE_INFO (*(struct drive_info *)0x90080)
#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)

struct drive_info { char dummy[32]; } drive_info;

//main函数 linux引导成功后就从这里开始运行
void main(void)		/* This really IS void, no error here. */
{			/* The startup routine assumes (well, ...) this */
/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
//前面这里做的所有事情都是在对内存进行拷贝
 	ROOT_DEV = ORIG_ROOT_DEV;//设置操作系统的根文件
 	drive_info = DRIVE_INFO;//设置操作系统驱动参数
    ...
}
```

## 规划物理内存格局，设置缓冲区，虚拟盘，主内存

具体规划如下：除内核代码和数据所占的内存空间之外，其余物理内存主要分为三部分，分别是主内存区，缓冲区和虚拟盘。主内存区是进程代码运行的空间，也包括内核管理进程的数据结构；缓冲区主要作为主机与外设进行数据交互的中转站；虚拟盘区是一个可选的区域，如果选择使用虚拟盘，就可以将外设上的数据先复制进虚拟盘区，然后加以使用。

主要是物理内存末端以及缓冲区末端的设定：

- 针对实际物理内存条大于16MB的情况，物理内存末端设定为16MB，其余情况不用更改
- 缓冲区末端的设定分为三种情况，大于12MB，6到12MB，小于6MB。

```c
#define EXT_MEM_K (*(unsigned short *)0x90002)
memory_end = (1<<20) + (EXT_MEM_K<<10);// 1MB + 扩展内存(MB)数
memory_end &= 0xfffff000;// 按页的倍数取整，忽略内存末端不足一页的部分
if (memory_end > 16*1024*1024)// 控制操作系统的最大内存为16M
	memory_end = 16*1024*1024;
if (memory_end > 12*1024*1024) 
	buffer_memory_end = 4*1024*1024;
else if (memory_end > 6*1024*1024)
	buffer_memory_end = 2*1024*1024;
else
	buffer_memory_end = 1*1024*1024;
main_memory_start = buffer_memory_end;// 缓冲区之后就是主存
#ifdef RAMDISK
	main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
#endif
```

![QQ图片20230531121504](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\QQ图片20230531121504.png)

从前往后分别是buffer_memory_end，main_memory_end，memory_end。

## 设置虚拟盘空间并初始化

## 内存管理结构mem_map初始化

系统调用**mem_init**(main_memory_start,memory_end)函数，先对主内存的管理结构进行设置。

系统通过mem_map[]对1MB以上的内存分页进行管理，记录一个页面的使用次数。使用`#define MAP_NR(addr) (((addr)-LOW_MEM)>>12)`宏函数可以计算出距start_mem1MB处的第一个页的页数，将这个页数记为k。首先是将start_mem到end_mem中的所有页数对应的mem_map初始化为USED，然后从k开始将之后的所有页数的mem_map初始化为0。mem_map的含义是对应页的使用计数，使用计数为0的页面视为空闲页面。

为什么系统只对主内存1MB以后的部分采用分页管理呢，是因为1MB以内是内核代码和只有内核管控的大部分数据所在的内存空间，不允许用户进程访问。1MB之后是用户进程的代码，数据所在的内存空间。

```c
// mm/memory.c:
#define LOW_MEM 0x100000// 1MB
#define PAGING_MEMORY (15*1024*1024)// 15MB
#define PAGING_PAGES (PAGING_MEMORY>>12)// 15MB / 4k,即15MB对应的页数
#define MAP_NR(addr) (((addr)-LOW_MEM)>>12)// (addr-1MB) / 4k
#define USED 100

static long HIGH_MEMORY = 0;
static unsigned char mem_map [ PAGING_PAGES ] = {0,};

void mem_init(long start_mem, long end_mem)
{
	int i;

	HIGH_MEMORY = end_mem;
	for (i=0 ; i<PAGING_PAGES ; i++)
		mem_map[i] = USED;
	i = MAP_NR(start_mem);
	end_mem -= start_mem;
	end_mem >>= 12;
	while (end_mem-->0)
		mem_map[i++]=0;
}
```

![QQ图片20230531121031](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\QQ图片20230531121031.png)

## 异常处理类中断服务程序挂接

trap_init()函数将中断，异常处理的服务程序与IDT进行挂接。

```c
// kernek/trap.c

void trap_init(void)
{
	int i;

	set_trap_gate(0,&divide_error);//如果被除数是0就会产生这个中断
	set_trap_gate(1,&debug);//单步调试的时候调用这个中断
	set_trap_gate(2,&nmi);
	set_system_gate(3,&int3);	/* int3-5 can be called from all */
	set_system_gate(4,&overflow);
	set_system_gate(5,&bounds);
	set_trap_gate(6,&invalid_op);
	set_trap_gate(7,&device_not_available);
	set_trap_gate(8,&double_fault);
	set_trap_gate(9,&coprocessor_segment_overrun);
	set_trap_gate(10,&invalid_TSS);
	set_trap_gate(11,&segment_not_present);
	set_trap_gate(12,&stack_segment);
	set_trap_gate(13,&general_protection);
	set_trap_gate(14,&page_fault);
	set_trap_gate(15,&reserved);
	set_trap_gate(16,&coprocessor_error);
	for (i=17;i<48;i++)
		set_trap_gate(i,&reserved);
	set_trap_gate(45,&irq13);
	outb_p(inb_p(0x21)&0xfb,0x21);
	outb(inb_p(0xA1)&0xdf,0xA1);
	set_trap_gate(39,&parallel_interrupt);
}

// include/asm/system.h
#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ ("movw %%dx,%%ax\n\t" \
	"movw %0,%%dx\n\t" \
	"movl %%eax,%1\n\t" \
	"movl %%edx,%2" \
	: \
	: "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
	"o" (*((char *) (gate_addr))), \
	"o" (*(4+(char *) (gate_addr))), \
	"d" ((char *) (addr)),"a" (0x00080000))

#define set_intr_gate(n,addr) \
	_set_gate(&idt[n],14,0,addr)
//idt就是中断描述表，这里就是往表里填中断号和中断程序的地址
#define set_trap_gate(n,addr) \
	_set_gate(&idt[n],15,0,addr)

#define set_system_gate(n,addr) \
	_set_gate(&idt[n],15,3,addr)
```

## 初始化块设备请求项结构

使用**blk_dev_init**()对块设备进行初始化。

Linux0.11将外设分为块设备和字符设备两类。

- 块设备将存储空间等分为若干同样大小的成为块的小存储空间，每个块有块号，可以独立、随机读写。硬盘、软盘都是块设备。
- 字符设备以字符为单位进行I/O通信。键盘、显示器都是字符设备。

进程想要与块设备进行沟通，必须经过主机内存中的缓冲区。请求项管理结构request[32]就是操作系统管理缓冲区中的缓冲块与块设备上逻辑块之间读写关系的数据结构。

![屏幕截图 2023-06-03 115215](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\屏幕截图 2023-06-03 115215.png)

```c
// kernel/blk_dev/blk.h

#define NR_REQUEST	32

/*
 * Ok, this is an expanded form so that we can use the same
 * request for paging requests when that is implemented. In
 * paging, 'bh' is NULL, and 'waiting' is used to wait for
 * read/write completion.
 */
struct request {
	int dev;		/* -1 if no request */
	int cmd;		/* READ or WRITE */
	int errors;
	unsigned long sector;
	unsigned long nr_sectors;
	char * buffer;
	struct task_struct * waiting;
	struct buffer_head * bh;
	struct request * next;
};

// kernel/blk_dev/ll_rw_block.c

struct request request{NR_REQUEST};

void blk_dev_init(void)
{
	int i;

	for (i=0 ; i<NR_REQUEST ; i++) {
		request[i].dev = -1;
		request[i].next = NULL;
	}
}
```

request[32]是一个由数组组成的链表，request[i].dev = -1说明了这个请求项还没有具体对应哪个设备，这个标志将来会被用来判断对应该请求项的当前设备是否空闲，request[i].next = NULL说明这时还没有形成请求项队列。

## 与建立人机交互界面相关的外设的中断服务程序挂接

Linux中本来设计chr_dev_init()函数去初始化字符设备，但这是一个空函数。其实是用tty_init()函数进行初始化字符设备。

字符设备初始化为进程与串行口，显示器以及键盘进行IO通信准备工作环境。

## 开启启动时间设置

CMOS是主板上的一个小存储芯片，系统通过调用time_init()函数先对它上面记录的时间数据进行采集，提取不同等级的时间要素，然后对这些要素进行整合，并最终得出开机启动时间。

```c
// init/main.c

#define CMOS_READ(addr) ({ \
outb_p(0x80|addr,0x70); \
inb_p(0x71); \
})

#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
static void time_init(void)//这一段代码起到从CMOS中读取时间信息的作用
{
	struct tm time;

	do {
		time.tm_sec = CMOS_READ(0);
		time.tm_min = CMOS_READ(2);
		time.tm_hour = CMOS_READ(4);
		time.tm_mday = CMOS_READ(7);
		time.tm_mon = CMOS_READ(8);
		time.tm_year = CMOS_READ(9);
	} while (time.tm_sec != CMOS_READ(0));
	BCD_TO_BIN(time.tm_sec);//把CMOS中读出来的数据进行转换
	BCD_TO_BIN(time.tm_min);
	BCD_TO_BIN(time.tm_hour);
	BCD_TO_BIN(time.tm_mday);
	BCD_TO_BIN(time.tm_mon);
	BCD_TO_BIN(time.tm_year);
	time.tm_mon--;
	startup_time = kernel_mktime(&time);//存在startup_time这个全局变量中，并且之后会被JIFFIES使用
	
}
```

kernel_mktime(&time)函数会基于传入的时间返回当前时间距离1970年1月1日0时所过的秒数，在`time_init`中，会将结果存放在全局变量`start_time`中。`start_time`后续会被jiffies系统滴答所使用（10ms一个滴答）。

每隔10ms会引发一个定时器中断`_timer_interrupt`，这个中断定义在`system_call.s`中（软中断放在system_call.s中这是可以预见的）。

```c
// kernel/mktime.c
long kernel_mktime(struct tm * tm)//这个tm是开机的时候从CMOS读出来的
{
	long res;
	int year;

	year = tm->tm_year - 70;
/* magic offsets (y+1) needed to get leapyears right.*/
	res = YEAR*year + DAY*((year+1)/4);
	res += month[tm->tm_mon];
/* and (y+2) here. If it wasn't a leap-year, we have to adjust */
	if (tm->tm_mon>1 && ((year+2)%4))
		res -= DAY;
	res += DAY*(tm->tm_mday-1);
	res += HOUR*tm->tm_hour;
	res += MINUTE*tm->tm_min;
	res += tm->tm_sec;
	return res;
}
```

## 初始化进程0

进程0是操作系统中运行的第一个进程，也是Linux操作系统父子进程创建机制的第一个父进程，进程0应该具有的能力：

- 系统先初始化进程0，进程0管理结构task_struct的母本(init_task = {INIT_TASK})已经在代码设计阶段事先设计好了，但这并不代表进程0可用，还要将进程0的task_struct中的LDT，TSS与GDT相挂接，并对GDT，task[64]以及与进程调度相关的寄存器进行初始化设置。
- Linux0.11作为一个现代操作系统，其最重要的标志就是能够支持多进程轮流执行，这要求进程具备参与多进程轮询的能力。系统这里对时钟中断进行设置，以便在进程0运行后，为进程0以及后续由它直接，间接创建出来的进程能够参与轮换奠定基础。
- 进程0要具备处理系统调用的能力，每个进程在运算时都可能要与内核进行交互，而交互的端口就是系统调用程序。系统通过函数set_system_gate将system_call与IDT相挂接，这样进程0就具备了处理系统调用的能力，system_call是系统调用的总入口。

上述三点的实现都是在sched_init()函数中实现的

```c
// kernek/sched.c
#define LATCH (1193180/HZ)

union task_union {
	struct task_struct task;
	char stack[PAGE_SIZE];
};

// 进程0的task_struct
static union task_union init_task = {INIT_TASK,};
void sched_init(void)
{
	int i;
	struct desc_struct * p;

	if (sizeof(struct sigaction) != 16)
		panic("Struct sigaction MUST be 16 bytes");
	//gdt是全局描述符（系统级别）和前面所说的ldt（局部描述符）对应
	//内核的代码段
	//内核的数据段
	//进程0...n的数据
	set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
	p = gdt+2+FIRST_TSS_ENTRY;
	for(i=1;i<NR_TASKS;i++) {//0-64进程进行遍历
		task[i] = NULL;
		p->a=p->b=0;
		p++;
		p->a=p->b=0;
		p++;
	}//作用是清空task链表
/* Clear NT, so that we won't have troubles with that later on */
	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
	ltr(0);
	lldt(0);
	//以下都是设置一些小的寄存器组
	outb_p(0x36,0x43);		/* binary, mode 3, LSB/MSB, ch 0 */
	outb_p(LATCH & 0xff , 0x40);	/* LSB */
	outb(LATCH >> 8 , 0x40);	/* MSB */
	set_intr_gate(0x20,&timer_interrupt);
	outb(inb_p(0x21)&~0x01,0x21);
	//设置系统中断
	set_system_gate(0x80,&system_call);
}

```

### 初始化进程0

**首先，声明了一个指针p，指向`desc_struct`**

```c
struct desc_struct * p;
```

`struct desc_strudt`定义在`include/linux/head.h`中

```c
typedef struct desc_struct {
	unsigned long a,b;
} desc_table[256];
```

我们可以看出`desc_struct`就是包含两个4字节变量一共八个字节的单元。对应在内核中就是我们的段描述符，a是段描述符的低32位（包括段限长和段基址），b是段描述符的高32位（包括段属性）。

**接下来是设置进程0的TSS和LDT**

需要注意的是进程的tss和ldt都是放在task_struct中的，我们所作的就是构造出两个段选择符指向进程0的tss和ldt，并将这两个段选择符放在gdt中。

```c
set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
```

我们先看看里面的参数，其中`FIRST_TSS_ENTRY`，`FIRST_LDT_ENTRY`是两个宏

```c
#define FIRST_TSS_ENTRY 4
#define FIRST_LDT_ENTRY (FIRST_TSS_ENTRY+1)
```

为啥FIRST_TSS_ENTRY的值定义为4呢？ 这是因为所有进程的TSS和LDT都是保存在系统的GDT 全局描述符表里面的。GDT前四项分别是空描述符，内核代码段描述符，内核数据段描述符，以及空描述符。之所以内核数据段后面任然有一个空描述符，设计者主要是想将内核描述符与进程的TSS,LDT分开。我们可以基于head.s中对gdt的设定进行验证

```c
gdt:	
	.quad 0x0000000000000000	/* NULL descriptor */
	.quad 0x00c09a0000000fff	/* 16Mb */
	.quad 0x00c0920000000fff	/* 16Mb */
	.quad 0x0000000000000000	/* TEMPORARY - don't use */
	.fill 252,8,0			/* space for LDT's and TSS's etc */
```

结合下面的图片可以非常直观的理解

![屏幕截图 2022-05-30 120558](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 120558.png)

接着就是gdt参数，定义在`include/linux/head.h`中

```c
extern desc_table idt,gdt;
```

`desc_table`就是来自刚才看到的

```c
typedef struct desc_struct {
	unsigned long a,b;
} desc_table[256];
```

也就是说gdt和idt就是段描述符的数组。那这样`gdt+FIRST_TSS_ENTRY`，就指向了GDT表中刚好应该放第0号进程描述符的位置。

然后我们看看对应调用的函数`set_tss_desc`

```c
#define _set_tssldt_desc(n,addr,type) \
__asm__ ("movw $104,%1\n\t" \
	"movw %%ax,%2\n\t" \
	"rorl $16,%%eax\n\t" \
	"movb %%al,%3\n\t" \
	"movb $" type ",%4\n\t" \
	"movb $0x00,%5\n\t" \
	"movb %%ah,%6\n\t" \
	"rorl $16,%%eax" \
	::"a" (addr), "m" (*(n)), "m" (*(n+2)), "m" (*(n+4)), \
	 "m" (*(n+5)), "m" (*(n+6)), "m" (*(n+7)) \
	)
#define set_tss_desc(n,addr) _set_tssldt_desc(((char *) (n)),((int)(addr)),"0x89")
#define set_ldt_desc(n,addr) _set_tssldt_desc(((char *) (n)),((int)(addr)),"0x82")

```

我们以`set_tss_desc`为例，首先将n转换为指向char的指针，也就是指向一个字节的指针，这样做是为了在`_set_tssldt_desc`宏中在对n进行加法的时候每次只加一个字节，可以一个字节一个字节的传参。将addr转换为int类型，传入`_set_tssldt_desc`宏中进行处理。

对于这个内联汇编

第0个参数："a" (addr)，将addr也就是&(init_task.task.tss)给eax.
第1个参数："m" (\*(n))，一个内存数，将n的值也就是gdt+4这个数，作为一个内存地址，这个其实就是gdt中进程0的TSS描述符的首字节。第0-1个字节共16位应该放着这个段的限长。
第2个参数： "m" (\*(n+2))，一个内存数，gdt中进程0的TSS描述符的第2个字节。第2-3字节放着这个基地址的低16位。
第3个参数："m" (\*(n+4))，进程0的tss段描述的第4个字节。这里面放的基地址的中8位。
第4个参数： "m" (\*(n+5))，进程0的tss段描述符的第5个字节，里面放的类型
第5个参数："m" (\*(n+6))，进程0的tss段描述符的第6个字节，里面放的段限长，粒度啥的
最后一个参数："m" (*(n+7))，进程0的tss段描述符的第7个字节，里面放的基地址的高8位。
所以这些参数其实就是构成了这个段描述符的各个部分。

"movw \$104,%1\n\t"设置段限长为104个单位。具体多少得看G位。也就是倒数第二个字节的最高位。
"movw %%ax,%2\n\t" \将输入的&(init_task.task.tss)地址给基地址的低16位。
"rorl \$16,%%eax\n\t" \，将eax右循环移动16位
"movb %%al,%3\n\t" \，al其中就是地址的中8位，第3个参数。
"movb \$" type ",%4\n\t" \,编译后就是"movb \$0x89,%4\n\t" \,而0x89=1000 1001。底4位1001是类型域，第5位S为0，说明这是一个系统描述符，而类型又是1001，说明这是一个32位的TSS系统描述符。第6-7位说明这个段的DPL为0，最高位存在位置1 。
"movb \$0x00,%5\n\t" \,给第5个参数，这个参数是控制粒度啥的，通过这个最高位为0，可以看出这个段的粒度为1B。所以这个段的限长为104个字节。其实TSS结构的长度就是104字节。
"movb %%ah,%6\n\t" \将基地址的最后的最高8位写到第6个参数。
"rorl \$16,%%eax" \,eax再右循环移位就是让eax设置为0了。

**经过上述过程，将gdt里面的第一个TSS描述符就做好了，这个描述符的基地址指向`init_task.tss`。同理LDT0也是这样操作，结合上副图进行理解。**

对于`init_task`就是我们0号进程的`task_struct`，定义在`include/linux/sched.h`中

```c
#define INIT_TASK \
/* state etc */	{ 0,15,15, \
/* signals */	0,{{},},0, \
/* ec,brk... */	0,0,0,0,0,0, \
/* pid etc.. */	0,-1,0,0,0, \
/* uid etc */	0,0,0,0,0,0, \
/* alarm */	0,0,0,0,0,0, \
/* math */	0, \
/* fs info */	-1,0022,NULL,NULL,NULL,0, \
/* filp */	{NULL,}, \
	{ \
		{0,0}, \
/* ldt */	{0x9f,0xc0fa00}, \
		{0x9f,0xc0f200}, \
	}, \
/*tss*/	{0,PAGE_SIZE+(long)&init_task,0x10,0,0,0,0,(long)&pg_dir,\
	 0,0,0,0,0,0,0,0, \
	 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \
	 _LDT(0),0x80000000, \
		{} \
	}, \
}
```

同时在`sched.c`中有这么一段代码

```c
union task_union {
	struct task_struct task;
	char stack[PAGE_SIZE];
};

static union task_union init_task = {INIT_TASK,};

long volatile jiffies=0;
long startup_time=0;
struct task_struct *current = &(init_task.task);//全局变量 指向当前运行的进程
struct task_struct *last_task_used_math = NULL;

struct task_struct * task[NR_TASKS] = {&(init_task.task), };

long user_stack [ PAGE_SIZE>>2 ] ;
```

我们只挑关键的来看，首先我们将`INIT_TASK`放入`init_task`联合体中，那么我们对`INIT_TASK`的访问就应该是`init_task.task`。然后我们将`init_task.task`的地址赋给current（当前进程，此时就是0号进程）。最后初始化了我们的task数组，并且让第一项指向`init_task.task`的地址。代表着我们task任务数组中的第一个任务（进程）就是0号进程。

OK，那么总的来看，经过下面两条语句，我们将TSS0和LDT0就做好了。

```c
set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
```

接着：

```c
p = gdt+2+FIRST_TSS_ENTRY;
	for(i=1;i<NR_TASKS;i++) {
		task[i] = NULL;
		p->a=p->b=0;
		p++;
		p->a=p->b=0;
		p++;
	}
```

那这段程序就很简单了，让指针指向`gdt+2+FIRST_TSS_ENTRY`，也就是gdt表中的第七个元素（索引为6）。然后进行遍历，将`task`第一个到第NR_TASKS-1个元素都赋值为NULL。在每次赋值的过程中，都让对应的gdt表中的两个描述符清0（对应进程的ldt和tss）

接着：

```c
ltr(0);
lldt(0);
```

`ltr`和`lldt`是两个宏，定义在`include/linux/sched.h`中，以`ltr`宏定义为例，将tr寄存器中的段选择子设置为指向进程0 tss段的段描述符。

```c
#define _TSS(n) ((((unsigned long) n)<<4)+(FIRST_TSS_ENTRY<<3))
#define _LDT(n) ((((unsigned long) n)<<4)+(FIRST_LDT_ENTRY<<3))
#define ltr(n) __asm__("ltr %%ax"::"a" (_TSS(n)))
#define lldt(n) __asm__("lldt %%ax"::"a" (_LDT(n)))
```

首先看`_TSS(n)`，这其实就是生成第n号进程TSS段的段选择子，首先`(FIRST_TSS_ENTRY<<3)` 代表将后三位空出来，`000`代表全局描述表以及特权级。而`(((unsigned long) n)<<4)`代表首先左移三位也是空出后三位，左移一位是因为一个进程有两个描述符（前面是偏移）。 `lldt(0)`的分析类似。需要注意的是我们`_TSS(n)`返回的是`unsigned long`类型的数据，并将其赋给eax寄存器，但是最后ltr指令仅操作低16位也就是`%ax`寄存器。

### 设置时钟中断

```c
outb_p(0x36,0x43);		/* binary, mode 3, LSB/MSB, ch 0 */
outb_p(LATCH & 0xff , 0x40);	/* LSB */
outb(LATCH >> 8 , 0x40);	/* MSB */
// 设置时钟中断
set_intr_gate(0x20,&timer_interrupt);
outb(inb_p(0x21)&~0x01,0x21);
```

### 设置系统调用总入口

```c
//设置系统中断
set_system_gate(0x80,&system_call);
```

## 初始化缓冲区管理结构

以缓冲区的初始化为切入点详解fork.c文件。

缓冲区是内存与外设（如硬盘）进行数据交换的媒介。操作系统通过hash_table[NR_HASH], buffer_head双向环链表组成的复杂哈希表管理缓冲区。通过buffer_init(buffer_memory_end)函数堆缓冲区进行设置。

```c
// include/linux/fs.h
struct buffer_head {
	char * b_data;			/* pointer to data block (1024 bytes) */
	unsigned long b_blocknr;	/* block number */
	unsigned short b_dev;		/* device (0 = free) */
	unsigned char b_uptodate;
	unsigned char b_dirt;		/* 0-clean,1-dirty */
	unsigned char b_count;		/* users using this block */
	unsigned char b_lock;		/* 0 - ok, 1 -locked */
	struct task_struct * b_wait;
	struct buffer_head * b_prev;
	struct buffer_head * b_next;
	struct buffer_head * b_prev_free;
	struct buffer_head * b_next_free;
};
// fs/buffer.c

// 内核代码末端地址，声明为外部变量
extern int end;
struct buffer_head * start_buffer = (struct buffer_head *) &end;
struct buffer_head * hash_table[NR_HASH];
static struct buffer_head * free_list;
static struct task_struct * buffer_wait = NULL;
int NR_BUFFERS = 0;

// buffer_end是缓冲区的末尾
void buffer_init(long buffer_end)
{
	struct buffer_head * h = start_buffer;
	void * b;
	int i;

	if (buffer_end == 1<<20)
		b = (void *) (640*1024);
	else
		b = (void *) buffer_end;
	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {
		h->b_dev = 0;
		h->b_dirt = 0;
		h->b_count = 0;
		h->b_lock = 0;
		h->b_uptodate = 0;
		h->b_wait = NULL;
		h->b_next = NULL;
		h->b_prev = NULL;
		h->b_data = (char *) b;
		h->b_prev_free = h-1;
		h->b_next_free = h+1;
		h++;
		NR_BUFFERS++;
		if (b == (void *) 0x100000)
			b = (void *) 0xA0000;
	}
	h--;
	free_list = start_buffer;
	free_list->b_prev_free = h;
	h->b_next_free = free_list;
	for (i=0;i<NR_HASH;i++)
		hash_table[i]=NULL;
}	
```

缓冲区并非从内存地址直接开始，因为那里有着内核代码区，而现在也很难估算内核代码结束的位置，因此我们设置一个外部变量，在链接阶段计算出内核代码区结束的位置。**我们将内核代码区开始的位置作为缓冲区管理结构**，为了建立缓冲区管理结构中的每一个结点与对应的一个缓冲区block的对应，从b = buffer_end开始（即缓冲区末尾），h = start_buffer开始（即缓冲区管理结构开始位置）建立起一一对应的结构。b每一次都减去一个BLOCK_SIZE然后与h进行比较，即查看当前缓冲区剩下的内存是否还余下一个block。缓冲区管理结构设置完后，将free_list设置为缓冲区管理结构的第一项也就是start_buffer，因为是一个循环链表，将free_list的前一个结点设置为h（当前h指向缓冲区管理结构的最后一项）。

缓冲区初始化过程中，初始化程序从整个缓冲区的两端开始，分别同时设置缓冲块头结构和划分出对应的缓冲块，缓冲区高端被划分成一个个1024字节的缓冲块，低端则分别建立起对应缓冲块的缓冲头结构buffer_end。该头结构用于描述对应缓冲块的属性，并且用于把所有缓冲头连接成链表，直到它们之间已经不能再划分出缓冲块为止。

![QQ图片20230715101001](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\QQ图片20230715101001.png)

所有缓冲块的buffer_end被链接成一个双向链表结构。free_list指针事该链表的头指针，指向空闲块链表中第一个“最为空闲的“缓冲块，即近期最少使用的缓冲块。而该缓冲块的反向指针b_prev_free则指向缓冲块链表中的最后一个缓冲块，即最近刚使用的缓冲块。

![QQ图片20230715101005](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\QQ图片20230715101005.png)

缓冲块数据结构为：

```c
struct buffer_head {
	char * b_data;			/* pointer to data block (1024 bytes) */
	unsigned long b_blocknr;	/* block number */
	unsigned short b_dev;		/* device (0 = free) */
	unsigned char b_uptodate;
	unsigned char b_dirt;		/* 0-clean,1-dirty */
	unsigned char b_count;		/* users using this block */
	unsigned char b_lock;		/* 0 - ok, 1 -locked */
	struct task_struct * b_wait;
	struct buffer_head * b_prev;
	struct buffer_head * b_next;
	struct buffer_head * b_prev_free;
	struct buffer_head * b_next_free;
};
```

其中，

- b_lock是锁定标志，表示驱动程序正在对该缓冲区内容进行修改，因此该缓冲块处于忙状态而正被锁定。
- b_count是缓冲管理程序buffer使用的计数值，表示相应缓冲块正在被各个进程使用的次数
- b_dirt是脏标志，说明缓冲块中内容是否已被修改而与块设备上的对应数据块内容不同。b_uptodate是数据更新有效标志，说明缓冲块中数据是否有效。

内核程序在使用高速缓冲区中的缓冲块时，是指定设备号（dev）和索要访问设备数据的逻辑块号（block），通过调用缓冲区块读取函数bread()，bread_page()或breada()进行操作。这几个函数都使用缓冲区搜索管理函数getblk()，用于在所有缓冲块寻找最为空闲的缓冲块。函数之间的调用关系如图所示

![QQ图片20230715125034](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\QQ图片20230715125034.png)

为了有效地在缓冲区中寻找判断请求出地数据块是否已经被读入到缓冲区中，buffer.c程序使用了具有375个buffer_head指针项的hash数据表结构。Hash表所使用的散列函数由设备号和逻辑块号通过异或操作组合而成。程序中使用的具体hash函数是：（设备号^逻辑块号）mod307。缓冲区的逻辑大致呈现下面的情形：hash表中存放着一个个buffer_head指针项，而每一个缓冲头都与一个缓冲块一一对应。

![QQ图片20230716225825](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\QQ图片20230716225825.png)

上面提及的三个函数在执行时都调用了getblk()，以获取适合的空闲缓冲块。该函数首先调用get_hash_table()函数，在hash表队列中搜索指定设备号和逻辑块号的缓冲块是否已经存在。如果存在就立刻返回对应缓冲头结构的指针；如果不存在，则从空闲链表头开始，对空闲链表进行扫描，寻找一个空闲缓冲块。可以看到，getblk()返回的缓冲块可能是一个新的空闲块，也可能是正好含有我们需要数据的缓冲块，它存在于高速缓冲区中。因此对于读取数据块操作（bread()），此时就要判断该缓冲块的更新标志，看看所含数据是否有效`if (bh->b_uptodate) return bh;` ,如果有效就可以直接将该数据块返回给申请的程序。否则就需要调用设备的低层块读写函数（ll_rw_block)，并同时让自己进入睡眠状态，等待数据被读入缓冲块。在醒来后再判断数据是否有效。

当程序不再需要使用一个缓冲块中的数据时，就调用brelse()函数，释放该缓冲块并唤醒因等待该缓冲块而进入睡眠状态的进程。

```c
struct buffer_head * bread(int dev,int block)
{
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))
		panic("bread: getblk returned NULL\n");
	if (bh->b_uptodate)
		return bh;
	ll_rw_block(READ,bh);
	wait_on_buffer(bh);
	if (bh->b_uptodate)
		return bh;
	brelse(bh);
	return NULL;
}
```

## 初始化硬盘

硬盘的初始化为进程与硬盘这种块设备进行I/O通信建立了环境基础。在hd_init()函数中，将硬盘请求项服务程序do_hd_request()函数来处理，然后将硬盘中断服务程序hd_interrupt()与IDT挂接，最后，复位主8259A int2的屏蔽位，允许从片发出中断请求信号；复位硬盘的中断请求屏蔽位，允许因硬盘控制器发送中断请求信号。

```c
// kernel/blk_dev/hd.c

void hd_init(void)
{
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
	set_intr_gate(0x2E,&hd_interrupt);
	outb_p(inb_p(0x21)&0xfb,0x21);
	outb(inb_p(0xA1)&0xbf,0xA1);
}
```

## 初始化软盘

软盘和软盘驱动器可以分离，合在一起才是一个整体。软盘初始化与硬盘初始化类似，挂接的函数是do_fd_request，初始化的是与软盘相关的中断。

```c
// kernel/floppy.c

void floppy_init(void)
{
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
	set_trap_gate(0x26,&floppy_interrupt);
	outb(inb_p(0x21)&~0x40,0x21);
}
```

## 开启中断

现在，系统中所有中断服务程序都已经和IDT正常挂接，这意味着中断服务体系已经构建完毕，系统可以在32位保护模式下处理中断。

```c
sti()
```

## 进程0由0特权级翻转到3特权级，成为真正的进程

**从内核态切换到用户态**

我们先回过去看看我们的`INIT_TASK`

```c
#define INIT_TASK \
/* state etc */	{ 0,15,15, \
/* signals */	0,{{},},0, \
/* ec,brk... */	0,0,0,0,0,0, \
/* pid etc.. */	0,-1,0,0,0, \
/* uid etc */	0,0,0,0,0,0, \
/* alarm */	0,0,0,0,0,0, \
/* math */	0, \
/* fs info */	-1,0022,NULL,NULL,NULL,0, \
/* filp */	{NULL,}, \
	{ \
		{0,0}, \
/* ldt */	{0x9f,0xc0fa00}, \
		{0x9f,0xc0f200}, \
	}, \
/*tss*/	{0,PAGE_SIZE+(long)&init_task,0x10,0,0,0,0,(long)&pg_dir,\
	 0,0,0,0,0,0,0,0, \
	 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \
	 _LDT(0),0x80000000, \
		{} \
	}, \
}
```

我们知道这个就是我们的0号进程的`task_struct`，我们关注其中的ldt和tss。

**ldt:**

```c
{ \
		{0,0}, \
		{0x9f,0xc0fa00}, \
		{0x9f,0xc0f200}, \
}\
```

ldt[0]是一个空描述符，ldt[1]是进程0的代码段描述符，ldt[2]是进程0的数据段描述符。（每个LDT中含有三个描述符，其中第一个不用，第二个是任务代码段的描述符，第三个是任务数据段和堆栈段的描述符。） 

在这其中有一个需要注意的点是：进程0的代码段就是内核的代码段。

那我们就先来看看进程0的ldt[1]。

`{0x9f,0xc0fa00}`展开完整(8个字节):`0x0000 009f,0x00c0 fa00`;其中第一个数在低32位,第二数在高32位
也就是:
高：
`0x00c0
0xfa00`
低：
`0x0000
0x009f`
转换为bit:

```c
63-48:00000000 11000000
47-32:11111010 00000000
31-16:00000000 00000000
15-00:00000000 10011111
```

对照着段描述符来看：

![屏幕截图 2022-05-29 085321](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 085321.png)

15-00为段限长:`0x009f`
31-16(最低16位):`00000000 00000000` ,39-32(次低8位):`00000000`,63-56(高8位):`00000000` 合并起来构成段基址：`00000000 00000000 00000000 00000000`,就是地址0。它的DPL为46-45位:11,也就是3

再来看看内核GDT的代码段描述符，在`head.s`中

```c
gdt:
	.quad 0x0000000000000000	/* NULL descriptor */
	.quad 0x00c09a0000000fff	/* 16Mb */
	.quad 0x00c0920000000fff	/* 16Mb */
	.quad 0x0000000000000000	/* TEMPORARY - don't use */
	.fill 252,8,0			/* space for LDT's and TSS's etc */
```

第2项`0x00 c0 9a 00 00 00 0f ff`为内核代码段
高:
`0x00c0
0x9a00`
低:
`0x0000
0x0fff`

```
63-48:00000000 11000000
47-32:10011010 00000000
31-16:00000000 00000000
15-00:00001111 11111111
```

它的31-16(最低16位)为`00000000 00000000 `,39-32(次低8位)为`00000000`,63-56(高8位)为`00000000` 合并起来构成段基址：`00000000 00000000 00000000 00000000`
DPL:00,也就是0。因此，进程0的代码段基址与内核的段基址是相同的，都为0，需要注意的是这里的段基址指的是线性地址（后续还需要通过分页机制变换到物理地址上），所以说两者段基址是可以接受的。

![屏幕截图 2022-05-31 154331](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-31 154331.png)

**第二个，我们来看看tss的内容**

```c
/*tss*/	{0,PAGE_SIZE+(long)&init_task,0x10,0,0,0,0,(long)&pg_dir,\
	 0,0,0,0,0,0,0,0, \
	 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \
	 _LDT(0),0x80000000, \
		{} \
	},
```

可以看到第二项为`PAGE_SIZE+(long)&init_task`，`init_task`我们前面介绍了，就是一个`task_union`联合体。

```c
union task_union {
	struct task_struct task;//小于4096
	char stack[PAGE_SIZE];//4096B
};
```

每个task_union都是包含4096字节，这刚好是一个页的大小。而这个task_union的前104个字节是一个task_struct结构。也就是说每个task_union的布局其实是这样的：
|---------------------------------------4096个字节----------------------------------------------------|
|-------task_struct----------|----------------------剩余未用---------------------------------------|
为什么会有这么多的剩余未用空间呢？其实这个剩余未用部分，就作为一个个进程的0特权栈来使用。我们都晓得，进程在运行期间很有可能使用调用system call函数的，而一调用system call函数，CPL就会从原来的3特权，翻转到0特权。而翻转特权以后，原来3特权的栈将不得被0特权的内核使用，于是Intel要求每个进程在创建之初都得指定一个0特权的栈，用于将来进程进入0特权时使用。

**move_to_user_mode()宏**

通过push和ret去修改寄存器的值从而完成特权级的切换

```c
#define move_to_user_mode() \
__asm__ (
	"movl %%esp,%%eax\n\t" \
	"pushl $0x17\n\t" \   
	"pushl %%eax\n\t" \
	"pushfl\n\t" \
	"pushl $0x0f\n\t" \ 
	"pushl $1f\n\t" \  
	"iret\n" \ 
	"1:\tmovl $0x17,%%eax\n\t" \ 
	"movw %%ax,%%ds\n\t" \
	"movw %%ax,%%es\n\t" \
	"movw %%ax,%%fs\n\t" \
	"movw %%ax,%%gs" \
	:::"ax")
```

我们一行行的分析。前面一部的压栈其实是在模拟INT n过程中需要执行的依次将ss,esp,eflag,cs,eip压栈。

`movl %%esp,%%eax`将esp内容给eax，esp是当前栈的栈顶，而当前用的是哪个栈呢？就是那个大小为一个页的user_stack的那个栈。
`pushl $0x17`，将0x17压入栈
`pushl %%eax`，将eax压入栈，也就是刚刚的那个旧的栈顶。
`pushfl` ，将eflag压栈
`pushl $0x0f` ，将0x0f压栈
`pushl $1f` ，将标号为1处指令的偏移压栈（它是iret的下一条指令）
看到这些push其实还不知道它要干什么，可以当看到iret时，我们就知道。
iret会隐含的执行以下指令：

```c
popl eip
popl cs
popl eflag
popl esp
popl ss
```

而这些pop就是与上面的push一一对应。因此，我们再回过头看看这些出栈以后寄存器保存的是啥。
首先eip 就是标号为1的指令的偏移，这是iret返回的下一条指令的偏移。

然后**cs为0x0f**,这是一个段选择子。0x0f=0000 1111,表示以RPL=3去选择LDT里面的第2项（索引为1）。当前的LDT表由对应的ldtr寄存器给出，在前面`shced_init()`函数中我们知道当前ldtr寄存器保存的是0号进程的ldt段选择符和ldt段描述符。那也就是说我们这个段选择子选择的是**0号进程的代码段**。当对cs寄存器赋值之后，后两位就代表当前进程特权级为3，也就是切换到了用户级。
再然后是eflag为eflag，这个没啥好说的。
这样就把特权级从3转到0了，其他的东西依然没变化。
之后就是一波ds,es,fs,gs的对齐，都对齐到0x17选择子上。这个选择子0x17=0001 0111,即**以RPL=3选择LDT的第3项(二进制10为2）**，即**0号进程的数据段和栈段。**

## 总结

当我们回顾整个流程，`move_to_user_mode()`函数执行完之后，就正式进入0号进程了。（也就是说我们可以在0号进程中执行指令了，而后续的任务fork()创建1号进程确实是在0号进程中进行的）。

一个进程想要在主机中正常运算需要做到以下条件：

1）在task中有一个指向自己task_struct的指针，且自己的task_struct已经创建并且初始化完毕。在GDT中存在着这个进程的TSS和LDT的段选择符。（在`sched_init()`中完成）

2）需要具备处理系统调用的能力（在`sched_init()`和`trap_init()`设置中断表，`sti()`函数开中断）

3）当前LDTR寄存器指向这个进程的ldt段选择符和段描述符，TR寄存器指向这个进程的tss段选择符和段描述符。（在`sched_init()`完成）

4）当前段寄存器保存正确的段选择符。（在`move_to_user_mode()`中完成）
