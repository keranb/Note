# 80x86保护模式及其编程

主要包括以下内容：

- 80X86基础知识
- 保护模式内存管理
- 各种保护措施
- 中断和异常处理
- 任务管理
- 保护模式编程的初始化

## 80X86基础知识（系统寄存器和系统指令）

**标志寄存器**

标志寄存器EFLAGS中的系统标志和IOPL字段用于控制I/O访问，可屏蔽硬件中断，调试，任务切换以及虚拟-8086模式。其它标志是一些通用标志（进位CF，奇偶PF，复制进位AF，零标志ZF，负号SF，方向DF，溢出OF）。

![屏幕截图 2022-05-28 212350](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-28 212350.png)

**内存管理寄存器**

![屏幕截图 2022-05-28 212825](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-28 212825.png)

局部描述符表寄存器LDTR LDTR寄存器中用于存放局部描述符表LDT（当前任务对应的LDT）的32位线性基地址、16位段限长和描述符属性值。指令LLDT和SLDT分别用于加载和保存LDTR寄存器的段描述符部分。包含LDT表的段必须在GDT表中有一个段描述符项。当使用LLDT指令把含有LDT表段的选择符加载进LDTR时，LDT段描述符的段基地址、段限长度以及描述符属性会被自动地加载到LDTR中。
任务寄存器TR TR寄存器用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值。
它引用GDT表中的一个TSS类型的描述符。指令LTR和STR分别用于加载和保存TR寄存器的段选择符部分。当使用LTR指令把选择符加载进任务寄存器时，TSS描述符中的段基地址、段限长度以及描述符属性会被自动地加载到任务寄存器中。

**控制寄存器**

控制寄存器（CR0,CR1,CR2和CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。

## 保护模式内存管理

### 内存寻址

内存是一组有序字节组成的数组，每个字节有唯一的内存地址。内存寻址是指对存储在内存中的某个指定数据对象的地址进行定位。内存物理地址空间有4G，总共可以寻址4G字节的物理内存。80X86首先存放低值字节，随后地址存放高值字节。

80X86使用了一种称为段的寻址技术。这中寻址技术把内存空间分成一个或多个称为段的线性区域，从而对内存中一个数据对象的寻址就需要使用一个段的起始地址（即段地址）和一个段内偏移地址两部分构成。段地址部分使用**16位的段选择符**来指定，其中14位可以选择$2^{14}$即16384个段，段内偏移地址部分使用**32位的值**来指定，因为段内地址可以是0到4G。即一个段的最大长度可达4G。程序中由16位的段和32位的偏移构成的48位地址或长指针称为一个逻辑地址。

### 地址变换

任何完整的内存管理系统都包含两个关键部分：保护和地址变换。提供保护措施是可以防止一个任务访问另外一个任务或操作系统的内存区域。地址变换能够让操作系统在给任务分配内存时具有灵活性，并且**因为我们可以让某些物理地址不被任何逻辑地址所映射，所以在地址变换过程中同时也提供了内存保护功能**。

程序中的地址是由两部分构成的逻辑地址，逻辑地址并不能直接用于访问物理内存，而需要使用地址变化机制将它变换或映射到物理内存地址上。内存管理机制即用于将这种逻辑地址转换为物理内存地址。

80X86从逻辑地址到物理地址变换过程中使用了分段和分页两种机制。第一阶段使用分段机制把程序的逻辑地址变换成处理器可寻址内存空间（称为线性地址空间）中的地址。第二阶段使用分页机制把线性地址转换为物理地址。在地址变换过程中，第一阶段的分段变化机制总是使用的，而第二阶段的分页机制则是供选用的。如果没有启用分页机制，那么分段机制产生的线性地址空间就直接映射到处理器的物理地址空间。

![屏幕截图 2022-05-28 215122](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-28 215122.png)

![屏幕截图 2022-05-28 215135](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-28 215135.png)

### 保护

这里的保护主要是指两个方面：任务之间的保护以及特权级保护（对操作系统内存段和处理器特殊系统寄存器的保护）

#### 任务之间的保护

通过把 每个任务放置在不同的虚拟地址空间中，并给与每个任务不同的逻辑地址到物理地址的变换映射。一个任务的逻辑地址映射到物理地址的一部分区域，另一个任务中的逻辑地址映射到物理地址的不同区域中。在80X86中每个任务都有自己的段表和页表。当处理器切换去执行一个新任务时，任务切换的关键部分就是切换到新任务的变换表。

通过在所有任务中安排具有相同虚拟到物理地址映射的部分（？）。并且把操作系统存储在这个公共的虚拟地址空间部分，操作系统可以被所有任务共享。这个所有任务都具有相同虚拟地址空间部分被称为全局地址空间。

每个任务唯一的虚拟地址空间部分被称为局部地址空间。局部地址空间含有需要与系统中其他任务区别开的私有的代码和数据。由于每个任务中具有不同的局部地址空间，因此两个不同惹怒我中对相同虚拟地址处的引用将转换到不同的物理地址处。这使得操作系统可以给与每个任务的内存相同的虚拟地址，但仍然能隔绝每个任务。（这里的一个理解是在一个任务中我只存在偏移地址的修改，对于不同的任务存在不同的段选择符，那么我给与相同的偏移地址也没事）。

#### 特权级保护

在一个任务中，定义了4个执行特权级，用于依据段中含有数据的敏感度以及任务中不同程序部分的受信程度，来限制对任务中各段的访问。

### 分段机制

**通常，每个程序都使用自己的段描述符表以及自己的段。**

段的基地址，段限长以及段的保护属性存储在一个称为段描述符的结构项中。在逻辑地址到线性地址的转换映射过程中会使用这个段描述符。段描述符保存在内存中的段描述符表中。段描述表是包含段描述符的一个简单数组。

为了把逻辑地址转换成一个线性地址，处理器会执行以下操作：

- 利用段选择符的偏移值在GDT或LDT表中定位相应的段描述符。（仅当一个新的段选择符加载到段寄存器中时才需要这一步）
- 利用段描述符检验段的访问权限和范围，以确保该段是可访问的并且偏移量位于段界限内。
- 把段描述符中取得的段基址加到偏移量上，最后形成一个线性地址。

段描述符表是段描述符的一个数组。描述符表存储在由操作系统维护着的特殊数据结构中。这些特殊结构应该保存在仅由操作系统软件访问的受保护的内存区域中，以防止应用程序修改其中的地址转换信息。

GDT，LDT并不是段，而是线性地址空间中的一个数据结构。GDT和LDT的基线性地址和长度值必须加载进GDTR和LDTR寄存器中。![屏幕截图 2022-05-29 084600](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 084600.png)

![屏幕截图 2022-05-29 084622](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 084622.png)

**段选择符**

段选择符是段的一个16位标识符，段选择符并不直接指向段，而是指向段描述表中定义段的段描述符。段选择符三个字段内容：

- 请求特权级RPL
- 表指示标志TI
- 索引值

选择符通过定位段表中的一个描述符来指定一个段，并且描述符中包含有访问一个段的所有信息，例如段的基地址，段长度和段属性。

**段描述符**

**每个段描述符是8个字节**，含有三个主要字段：段基地址，段限长和段属性。

![屏幕截图 2022-05-29 085321](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 085321.png)

### 分页机制

分页机制把线性和物理地址空间都划分成页面。线性地址空间中的任何页面可以被映射到物理地址空间的任何页面上。页表可以看作是简单的$2^{20}$物理地址数组。线性到物理地址的映射功能可以简单地看作是进行数组查找。线性地址的高20位构成这个数组的索引值，用于选择对应页面的物理（基）地址。线性地址的低12位给出页面中的偏移量，加上页面的基地址最终形成对应的物理地址。

为了减少内存占用量，80X86使用了两级表。由此，高20位线性地址到物理地址的转换也被分成两步来进行，每步使用其中10个比特。

## 保护

### 段级保护

主要分为以下几类：

- 段界限检查
- 段类型检查
- 特权级检查
- 可寻址范围限制
- 过程入口点限制
- 指令集限制

**段类型TYPE检查**

除了应用程序代码和数据段有描述符以外，处理器还有**系统段和门**两种描述符类型。这些数据结构用于管理任务以及异常和中断。（像TYPE=12就代表调用门）。并非所有的描述符都定义一个段，门描述符中存放有指向一个过程入口点的指针。段描述符在两个地方含有类型信息，即描述符中的S标志和类型字段TYPE。

S标志用于指出一个描述符是系统类型的还是代码或数据类型的。TYPE字段另外提供了4个比特位用于定义代码，数据和系统描述符的各种类型。

当操作段选择符和段描述符时，处理器会随时检查类型信息。主要在以下两种情况下检查类型信息：

- 当一个描述符的选择符加载进一个段寄存器中。此时某些寄存器中只能存放特定类型的描述符，例如：
  - CS寄存器中只能被加载进一个可执行段的选择符
  - 不可读可执行段的选择符不能被加载进数据段寄存器中
  - 只有可写数据段的选择符才能被加载进SS寄存器中
- 当指令访问一个段，而该段的描述符已经加载进段寄存器中，指令只能使用某些预定义的方法来访问某些段。
  - 任何指令不能写一个可执行段
  - 任何指令不能写一个可写位没有置位的数据段。（该数据段可以是可写的也可以是非可写的）
  - 任何指令不能读一个可执行段，除非可执行段设置了可读标志

**特权级**

- 当前特权级CPL。CPL是当前正在执行程序或任务的特权级。他存放在CS和SS段寄存器的位0和位1中。通常，CPL等于当前代码段的特权级。当程序把控制转移到另一个具有不同特权级的代码段中时，处理器就会改变CPL。当访问一个**一致性（conforming）代码段**时，则处理器对CPL的设置有些不同。特权级值高于（即低特权级）或等于一致代码段DPL的任何段都可以访问一致代码段。并且当处理器访问一个特权级不同于CPL的一致代码段时，CPL并不会被修改成一致代码段的DPL。
- 描述符特权级DPL（Descriptor Privilege Level）。DPL是一个段或门的特权级。它存放在段或门描述符的DPL字段中。在当前执行代码段试图访问一个段或门时，段或门的DPL会用来与CPL以及段或门选择符中的RPL（见下面说明）作比较。根据被访问的段或门的类型不同，DPL也有不同的含义：
  - 数据段（Data Segment）。其DPL指出允许访问本数据段的程序或任务应具有的最大特权级数值。例如，如果数据段的特权级DPL是1，那么只有运行在CPL为0或1的程序可以访问这个段。
  - 非一致代码段（Nonconforming code segment）（不使用调用门）。其DPL指出程序或任务访问该段必须具有的特权级。例如，如果某个非一致代码段的DPL是0，那么只有运行在CPL为0的程序能够访问这个段。
  - 调用门（Call Gate）。其DPL指出访问调用门的当前执行程序或任务可处于的最大特权级数值。（这与数据段的访问规则相同。）
  - 一致和非一致代码段（**通过调用门访问**）。其DPL指出允许访问本代码段的程序或任务应具有的最小特权级数值。例如，如果一致代码段的DPL是2，那么运行在CPL为0的程序就不能访问这个代码段。（**只能从低特权级跳转到高特权级）**
  - 任务状态段TSS。其DPL指出访问TSS的当前执行程序或任务可处于的最大特权级数值。（这与数据段的访问规则相同。）
- 请求特权级RPL（Request Privilege Level）。RPL是一种赋予段选择符的超越特权级，它存放在选择符的位0和位1中。处理器会同时检查RPL和CPL，以确定是否允许访问一个段。即使程序或任务具有足够的特权级（CPL）来访问一个段，但是如果提供的RPL特权级不足的话访问也将被拒绝。也即如果段选择符的RPL其数值大于CPL，那么RPL将覆盖CPL（而使用RPL作为检查比较的特权级），反之也然。即始终取RPL和CPL中数值最大的特权级作为访问段时的比较对象。因此，RPL可用来确保高特权级的代码不会代表应用程序去访问一个段，除非应用程序自己具有访问这个段的权限。

> 一致性代码和非一致性代码
>
> **一致代码段**
>
> 一致代码段：简单理解就是操作系统拿出来被共享的代码段，可以被低特权级的用户程序直接调用访问的代码段，这些代码段，通常是不去访问受保护的资源和某些类型异常处理。
>
> 一致代码段访问限制：
>
> 1. 特权级高的程序不允许访问特权级第的数据：即内核态不允许调用用户态的数据。
> 2. 特权级低的程序可以访问到特权级高的程序，但是特权级不会改变，即不会从用户态切换到内核态。
>
> **非一致代码段**
>
> 非一致代码段：为了避免低特权级的访问而被操作系统保护起来的系统代码
>
> 非一致代码段访问限制：
>
> 1. 只允许同特权级访问。
> 2. 绝对禁止不同特权级直接访问：内核态不去用户态，用户态也不使用内核态。
> 3. 通常低特权级代码必须通过`门调用`来实现对高特权级代码段的访问和调用。

当段描述符的段选择符被加载进一个段寄存器时就会进行特权级检查操作，但用于数据访问的检查方式和那些用于在代码段之间进行程序控制转移的检查方式不一样。因此下面分两种访问情况来考虑。

### 访问数据段时的特权级检查

为了访问数据段的操作数，数据段的段选择符必须被加载进数据段寄存器或堆栈段寄存器中。在把一个段选择符加载进段寄存器之前，处理器会进行特权级检查。![屏幕截图 2022-05-29 151240](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 151240.png)

### 代码段之间转移控制时的特权级检查

JMP,CALL,RET指令的远转移形式

JMP或CALL指令可以利用一下四种方法之一来引用另外一个代码段：

- 目标操作数含有目标代码段的段选择符：
- 目标操作数指向一个调用门描述符，而该描述符中含有目标代码段的选择符：
- 目标操作数指向一个TSS，而该TSS中含有目标代码段的选择符：
- 目标操作数指向一个任务门，该任务门指向一个TSS，而该TSS中含有目标代码段的选择符：

下面描述前两种引用类型，后两种将放在有关任务管理一节中进行说明。

#### 直接调用或跳转到代码段

对于将程序控制权从一个代码段转移到另一个代码段，目标代码段的段选择符必须加载进代码段寄存器(CS)中。作为这个加载过程的一部分，处理器会检测目标代码段的段描述符并执行各种限长，类型和特权级检查。如果这些检查都通过了，则目标代码段选择符就会加载进CS寄存器。![屏幕截图 2022-05-29 151721](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 151721.png)

处理器检查CPL、RPL和DPL的规则依赖于一致标志C的设置状态。当访问非一致代码段时（C=0），调用者（程序）的CPL必须等于目的代码段的DPL。当非一致代码段的段选择符被加载进CS寄存器中时，特权级字段不会改变，即它仍然是调用者的CPL。
当访问一致代码段时（C=1），调用者的CPL可以在数值上大于或等于目的代码段的DPL。
当程序控制被转移到一个一致代码段中，CPL并不改变，即使目的代码段的DPL在数值上小于CPL。**这是CPL与可能与当前代码段DPL不相同的唯一一种情况。**同样，由于CPL没有改变，因此堆栈也不会切换。

#### 通过调用门访问代码段

**先介绍一下门描述符。**

为了对具有不同特权级的代码段提供受控的访问，处理器提供了称为门描述符的特殊描述符集。共有4种门描述符：

- 调用门（Call Gate），类型TYPE=l2；

- 陷阱门（Trap Gate），类型TYPE=l5；

- 中断门（nterrupt Gate），类型TYPE=l4：

- 任务门（Task Gate），类型TYPE=5。

任务门用于任务切换，将在后面任务管理一节说明。陷阱门和中断门是调用门的特殊类，专门用于调用异常和中断的处理程序。调用门用于**在不同特权级之间实现受控的程序控制转移**。它们通常仅用于使用特权级保护机制的操作。一个调用门主要具有以下几个功能：

- 指定要访问的代码段：
- 在指定代码段中定义过程（程序）的一个入口点：
- 指定访问过程的调用者需具备的特权级：
- 若会发生堆栈切换，它会指定在堆栈之间需要复制的可选参数个数：
- 指明调用门描述符是否有效。

![屏幕截图 2022-05-29 161813](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 161813.png)

为了访问调用门，我们需要为CALL或JMP指令的操作数提供一个远指针。该指针中的段选择符用于指定调用门。

![屏幕截图 2022-05-29 162133](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 162133.png)

![屏幕截图 2022-05-29 162331](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 162331.png)

使用CALL指令和JMP指令分别具有不同的特权级检测规则。调用门描述符的DPL字段指明了调用程序能够访问调用门的数值最大的特权级（最小特权级），即为了访问调用门，调用者程序的特权级CPL必须小于或等于调用门的DPL。调用门段选择符的RPL也需同调用这的CPL遵守同样的规则，即RPL也必须小于或等于调用门的DPL。

| 指令 | 特权检查规则                                                 |
| ---- | ------------------------------------------------------------ |
| CALL | CPL<=调用门的DPL:RPL<=调用门的DPL.                                                                                                     对于一致性和非一致性代码段都只要求DPL<=CPL |
| JMP  | CPL<=调用门的DPL:RPL<=调用门的DPL.                                                                                                  对于一致性代码段要求DPL<=CPL：对于非一致性代码段只要求DPL=CPL |

#### 堆栈切换

每当调用门把程序控制转移到一个更高级别的非一致性代码段时（比如说从用户态到内核态），CPU会自动切换到目的代码段特权级的堆栈去。

当特权级3的程序在执行时，特权级3的堆栈的段选择符和栈指针会被分别存放在SS和ESP中，并且在发生堆栈切换时被保存在被调用过程的堆栈上。

特权级0，1，2堆栈的初始指针值都存放在当前运行任务的TSS段中。TSS段中这些指针都是只读值。当调用更高特权级程序时，CPU才用它们来建立新堆栈。当从调用过程返回时，相应栈就不存在了（SS和ESP被源程序的SS和ESP覆盖了，故被调用过程的堆栈就不见了）。下一次再调用该过程时，就又会再次使用TSS中的初始指针值建立一个新栈。

当通过调用门执行一个过程调用而造成特权级改变时，CPU就会执行以下步骤切换堆栈并开始在新的特权级上执行被调用过程：

- 使用目的代码段的DPL（即新的CPL）从TSS中选择新栈的指针。从当前TSS中读取新栈的段选择符和栈指针。在读取栈段选择符、栈指针或栈段描述符过程中，任何违反段界限的错误都将导致产生一个无效TSS异常：
- 检查栈段描述符特权级和类型是否有效，若无效者同样产生一个无效TSS异常。
- 临时保存SS和ESP寄存器的当前值，把新栈的段选择符和栈指针加载到SS和ESP中。然后把临时保存的SS和ESP内容压入新栈中。
- 把调用门描述符中指定参数个数的参数从调用过程栈复制到新栈中。调用门中参数个数值最大为31，如果个数为0，则表示无参数，不需复制。
- 把返回指令指针（即当前CS和EP内容）压入新栈。把新（目的）代码段选择符加载到CS中，同时把调用门中偏移值（新指令指针）加载到EIP中。最后开始执行被调用过程。

![屏幕截图 2022-05-30 085304](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 085304.png)

#### 从被调用过程返回

指令RET用于执行**近返回（near retur）、同特权级远返回（far return）和不同特权级的远返回**。该指令用于从使用CALL指令调用的过程中返回。

- 近返回仅在当前代码段中转移程序控制权，因此CPU仅进行界限检查。
- 对于相同特权级的远返回，CPU同时从堆栈中弹出返回代码段的选择符和返回指令指针。
- 会发生特权级改变的远返回仅允许返回到低特权级程序中，即返回到的代码段DPL在数值上要大于CPL.CPU会使用CS寄存器中选择符的RPL字段来确定是否要求返回到低特权级。

当执行远返回到一个调用过程时，CPU会执行以下步骤：

- 检查保存的CS寄存器中RPL字段值，以确定在返回时特权级是否需要改变。
- 弹出并使用被调用过程堆栈上的值加载CS和EIP寄存器。在此过程中会对代码段描述符和代码段选择符的RPL进行特权级与类型检查。
- 如果RET指令包含一个**参数个数**操作数并且返回操作会改变特权级，那么就在弹出栈中CS和EP值之后把参数个数值加到ESP寄存器值中，以**跳过（丢弃）被调用者栈上的参数**。此时ESP寄存器指向原来保存的调用者堆栈的指针SS和ESP。
- 把保存的SS和ESP值加载到SS和ESP寄存器中，从而切换回调用者的堆栈。而此时被调用者堆栈的SS和ESP值被抛弃。
- 如果RET指令包含一个参数个数操作数，则把参数个数值加到ESP寄存器值中，以跳过（丢弃）调用者栈上的参数。
- 检查段寄存器DS、ES、FS和GS的内容。如果其中有指向DPL小于新CPL的段（一致代码段除外），那么CPU就会用NULL选择符加载加载这个段寄存器。

## 中断和异常处理

**中断源：**

- 外部（硬件产生）的中断
- 软件产生的中断

**异常源：**

- 处理器检测到的程序错误异常
- 软件产生的异常

**异常分类：**

根据异常被报告的方式以及导致异常的指令是否能够被重新执行，异常可被细分成故障（Faut）、陷阱（Tra即）和中止（Abort）。

- Fault是一种通常可以被纠正的异常，并且一旦被纠正程序就可以继续运行。当出现一个Faut，处理器会把机器状态恢复到产生Fut的指令之前的状态。此时异常处理程序的返回地址会指向产生Fault的指令，而不是其后面一条指令。因此在返回后产生Fault的指令将被重新执行。
- Tap是一个引起陷阱的指令被执行后立刻会报告的异常。Trap也能够让程序或任务连贯地执行。Trp处理程序的返回地址指向引起陷阱指令的随后一条指令，因此在返回后会执行下一条指令。
- Abot是一种不会总是报告导致异常的指令的精确位置的异常，并且不允许导致异常的程序重新继续执行。Aot用于报告严重错误，例如硬件错误以及系统表中存在不一致性或非法值。

### 中断描述表IDT和IDT描述符

与GDT和LDT类似，IDT也是由8字节长描述符组成的一个数组。为了构成IDT表中的一个索引值，处理器把异常或中断的向量号*8.![屏幕截图 2022-05-30 090749](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 090749.png)

IDT表中可以存放三种类型的门描述符：

- 中断门（Interrupt gate）描述符
- 陷阱门（Trap gate）描述符
- 任务门（Task gate）描述符

中断门和陷阱门含有一个长指针（即段选择符和偏移值），处理器使用这个长指针把程序执行权转移到代码段中异常或中断的处理过程中。这两个段的主要区别在于处理器操作EFLAGS寄存器F标志上。

IDT中任务门描述符的格式与GDT和LDT中任务门的格式相同。任务门描述符中含有一个任务TSS段的选择符，该任务用于处理异常和/或中断。![屏幕截图 2022-05-30 090953](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 090953.png)

### 异常与中断的处理

处理器对异常和中断处理过程的调用操作方法与使用CALL指令调用程序过程和任务的方法类似。当响应一个异常或中断时，处理器使用异常或中断的向量作为IDT表中的索引。如果索值指向中断门或陷阱门，则处理器使用与**CALL指令操作调用门类似的方法**调用异常或中断处理过程。如果索引值指向任务门，则处理器使用与**CALL指令操作任务门类似的方法**进行任务切换，执行异常或中断的处理任务。
**异常或中断门**引用运行在当前任务上下文中的异常或中断处理过程，门中的段选择符指向GDT或当前LDT中的可执行代码段描述符。门描述符中的偏移字段指向异常或中断处理过程的开始处。

![屏幕截图 2022-05-30 091228](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 091228.png)

当处理器执行异常或中断处理过程调用时会进行以下操作：
如果处理过程**将在高特权级**（例如0级）上执行时（即中断处理程序所在代码段的DPL特权级较高）就会发生堆栈切换操作。堆栈切换过程如下：

- 处理器从当前执行任务的TSS段中得到中断或异常处理过程使用的堆栈的段选择符和栈指针（例如tss.ss0、tss.Csp0）。然后处理器会把被中断程序（或任务）的栈选择符和栈指针压入新栈中。
- 接着处理器会把EFLAGS、CS和EIP寄存器的当前值也压入新栈中。
- 如果异常会产生一个错误号，那么该错误号也会被最后压入新栈中。

如果处理过程将在被中断任务**同一个特权级上运行**，那么：

- 处理器把EFLAGS、CS和EIP寄存器的当前值保存在当前堆栈上。
  如果异常会产生一个错误号，那么该错误号也会被最后压入新栈中。

![屏幕截图 2022-05-30 091504](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 091504.png)

**中断处理任务**

当通过DT中任务门来访问异常或中断处理过程时就会导致任务切换。使用单独的任务来处理异常或中断有如下好处：

- 被中断程序或任务的完整上下文会被自动保存
- 在处理异常或中断时，新的TSS可以允许处理过程使用新特权级0的堆栈。在当前特权级0的堆栈已毁坏时如果发生了一个异常或中断，那么在为中断过程提供一个新特权级0的堆栈条件下，通过任务门访问中断处理过程能够防止系统崩溃
- 通过使用单独的LDT给中断或异常处理任务独立的地址空间，可以把它与其他任务隔离开来。

使用独立任务处理异常或中断的不足之处是：在任务切换时必须对大量机器状态进行保存，使得它比使用中断门的响应速度要慢，导致中断延时增加。

![屏幕截图 2022-05-30 092931](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 092931.png)

## 任务管理

任务（Tsk）是处理器可以分配调度、执行和挂起的一个工作单元。它可用于执行程序、任务或进程、操作系统服务、中断或异常处理过程和内核代码。一个任务由两部分构成：任务执行空间和任务段TSS。任务执行空间包括代码段，堆栈段和一个或多个数据段。

一个任务使用指向其TSS的段选择符来指定。当一个任务被加载进处理器中执行时，那么该任务的选择符、基地址、段限长以及TSS段描述符属性就会被加载进任务寄存器TR（Task Register）中。

软件或处理器可以使用以下方法之一来调度执行一个任务：

- 使用CALL指令明确地调用一个任务
- 使用JMP指令明确地跳转到一个任务（Lix内核使用的方式）
- （由处理器）隐含地调用一个中断句柄处理任务
- 隐含地调用一个异常句柄处理任务

### 任务管理数据结构

- 任务状态段TSS
- TSS描述符
- 任务寄存器TR
- 任务门描述符
- 标志寄存器EFLAGS中的NT标志。

**TSS**

注意LDT段选择符

![屏幕截图 2022-05-30 094416](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 094416.png)

**TSS描述符**

![屏幕截图 2022-05-30 094456](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 094456.png)

**任务门描述符**

任务门描述符中的TSS选择符字段指向GDT中的一个TSS段描述符。这个TSS选择符字段中的RPL域不用。任务门描述符中的DPL用于在任务切换时控制对TSS段的访问。当程序通过任务门调用或跳转到一个任务时，程序的CPL以及指向任务门的门选择符的RPL值必须小于或等于任务门描述符中的DPL。

![屏幕截图 2022-05-30 094651](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 094651.png)

### 任务切换

处理器可使用一下4种方式之一执行任务切换操作：

- 当前任务对GDT中的TSS描述符执行JMP或CALL指令
- 当前任务对GDT或LDT中的任务门描述符执行JMP或CALL指令
- 中断或异常向量指向DT表中的任务门描述符
- 当EFLAGS中的NT标志置位时当前任务执行IRET指令。

![屏幕截图 2022-05-30 095909](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-30 095909.png)
