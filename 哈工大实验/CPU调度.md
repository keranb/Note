# CPU调度

不同场景下的操作系统任务调度，调度策略的目标不同，调度算法的设计和实现原则就不同。

在PC机上的任务调度策略主要考虑如下三个基本准则：

- 任务的周转时间，即任务从新建进入操作系统到该任务完成离开操作系统所经历的全部时间
- 任务的响应时间，即从用户向某程序发起**一个交互操作**（注意理解一个交互操作的含义）到该任务响应这个操作之间经历的时间
- 系统吞吐量，即一段时间区域内计算机系统能完成的任务总数

在PC机上，交互式任务和非交互式任务同时存在，而且这两种任务有各自的目标：交互式任务（前台任务）不关心周转时间，强调响应时间；非交互式任务（后台任务）关心周转时间，在执行过程中无需交互。在两类任务同时存在的背景下，给出能有效折中的任务调度策略就成为通用操作系统在实现CPU调度时要分析的核心问题。

## CPU调度的基本算法

### 先来先服务（FCFS）

### 最短作业优先调度（SJF）

可以证明SJF算法能够产生最短的总周转时间以及最短的平均周转时间。需要注意的是任务不可能一下子都出现在零时刻，实际环境中可以工作的是最短剩余时间优先调度（SRTF），具体表现为每当新任务到达时，选择当前剩余执行时间最短的那个任务调度执行。显然，SRTF是一种可抢占式调度，即不是由任务自身主动让出CPU才引起的调度。实现可抢占式调度并不困难，即在线程/进程变为就绪态时（有新任务到达）调用schedule()函数。

### 时间片轮转调度（RR）

针对旨在缩小周转时间的非交互式任务而然，SRTF看起来是一个可以解决问题的调度算法。但是SRTF会带来很差的响应时间。

时间片轮转调度的基本思想是将一段时间等分地分割给每一个任务，即给每一个任务分配一个执行时间片，当前任务的时间片用完时就切换到下一个任务。

### 多级队列调度

为了发挥RR和SRTF算法各自的优点，一个很自然的想法时引入两个就绪队列，即交互任务队列和非交互任务队列（前台任务队列和后台任务队列）。前台队列采用RR调度，后台队列采用SRTF调度。

### 多级反馈队列调度（MLFQ）

多级队列调度仍然存在一定的问题，倘若我们采取的是非抢占式调度，那么一旦后台任务调度得到CPU，就只能等到执行完之后才能释放CPU，这段时间到达的前台任务的最差响应时间就可能很长。倘若采用可抢占式调度，只要有前台任务出现，就必须切换到前台任务队列，而且要一直等到前台任务队列中没有任务才能调度到后台队列。解决这个两难问题的方法是：即使有前台任务，后台任务也能调度到CPU，但又不能等待后台任务执行完之后才让出CPU。显然，后台任务也应该按照时间片来调度，即使有前台任务，后台任务也能得一个执行时间片。

第二个问题是：操作系统如何知道哪些任务是前台任务，哪些任务是后台任务？且前后台任务也并非是一成不变的。所以多级反馈队列调度中的任务类型不应该在任务创建时就固定下来，而应该根据任务在执行过程的具体表现来动态调整。这个动态调整就是多级反馈队列调度中反馈要表达的含义。任意想到的动态调整方案有I/O动态调整和按照执行时长动态调整。

在一个工作的生命周期中，MLQF改变任务的优先级，也就是确定任务在那个队列中，要注意的是，工作负载中，既有运行时间很短，频繁放弃CPU的交互型工作，也有需要很多CPU时间，响应时间却不重要的长时间计算密集型工作，下面是一种优先级调整策略.

1.工作进入系统时，放在最高优先级，也就是最上层队列．

2.工作用完整个时间片后，降低其优先级（移如下一级队列)

3.如果工作在其时间片以内主动释放CPU,则优先级不变．

这个算法的一个主要目标，如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级，如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。

**一些改进**：

- 提升优先级

  为了更好的避免饥饿问题，让后台任务能够得到CPU，一个简单的思路是经过一段时间S，就将系统中所有任务重新加入最高优先级队列

- 更好的计时方式

  一旦任务用完了其在某一队列中的时间配额（无论中间**主动**放弃了多少次CPU），就降低其优先级

## Linux0.11中的调度算法

```c
while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;//进程为空就继续循环
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)//找出c最大的task
				c = (*p)->counter, next = i;
		}
		if (c) break;//如果c找到了，就终结循环，说明找到了
		//进行时间片的重新分配
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)//这里很关键，在低版本内核中，是进行优先级时间片轮转分配，这里搞清楚了优先级和时间片的关系
			//counter = counter/2 + priority
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
```

注意counter的作用，一方面作为时间片执行时间片轮转算法，即每次在就绪态队列中寻找最大时间片对应的进程。如果当前就绪态队列中的所有进程的时间片都用完了，那么将**所有进程（包括阻塞态）**的时间片进行更新。对于阻塞态进程来说，当前发生了阻塞（进行IO操作），那操作系统就判定你当前作为前台进程，因为阻塞进程还具有一定的counter，所以在当前算法更新counter后必定会带来一个较大的counter，也就是说我们将阻塞进程（IO进程）的counter提高了，一旦阻塞进程回到就绪态就能以较高的counter抢占到CPU。
