# 实验4基于内核栈切换的进程切换

首先，我们介绍了用户级线程和内核级线程，内核级线程切换与进程切换的不同就是进程切换存在着映射表的切换。在Linux-0.11中没有内核级线程的概念，只有线程和进程的概念，而且使用tss通过一个长跳转指令进行切换，要知道长跳转指令的执行周期很长，无法好好利用到指令流水的优化，相比较而言，我们使用内核栈进行切换更加迅速方便。而在这个实验中我们所做的就是将linux0.11的源码进行魔改，让进程的切换方式变为基于内核栈的切换（注意是进程的切换）。主要包含对进程切换部分以及进程创建部分源码的修改。只要我们理解了内核栈切换的过程，那么对源码的修改就不难了。

## 内核栈的切换

我们分析内核级线程的切换就能明白内核栈的切换过程。从某个应用程序出发。

首先，通过中断由用户栈切换到内核栈，这里对中断在做更深一步的理解。通过int指令加索引选择IDT表中的一个中断门或者陷阱门描述符，在通过描述符找到入口地址之前有一些硬件上的操作，这与CALL,JMP指令选择一个调用门描述符类似。基于选择符的DPL和当前CPL判断是否发生特权级的改变，如果特权级发生改变，则**硬件**进行如下操作：

- 一些检查
- 临时保存SS和ESP的值，把新栈指针和新段选择符加载到SS和ESP中
- 将调用门描述符中指定参数的个数从调用过程栈复制到新栈
- 将返回指令指针CS和EIP压入新栈

![image-20220619193919820](C:\Users\可燃冰\AppData\Roaming\Typora\typora-user-images\image-20220619193919820.png)

我们以系统调用函数fork()为例，执行`int0x80`中断，对应的中断向量函数就是`system_call`

```c
system_call:
    cmpl $nr_system_calls-1,%eax
    ja bad_sys_call
    push %ds
    push %es
    push %fs
    pushl %edx
    pushl %ecx      # push %ebx,%ecx,%edx as parameters
    pushl %ebx      # to the system call
    movl $0x10,%edx        # set up ds,es to kernel space
    mov %dx,%ds
    mov %dx,%es
    movl $0x17,%edx        # fs points to local data space
    mov %dx,%fs
    call sys_call_table(,%eax,4)
    pushl %eax
    movl current,%eax
    cmpl $0,state(%eax)        # state
    jne reschedule
    cmpl $0,counter(%eax)      # counter
    je reschedule
ret_from_sys_call:
	movl _current,%eax		# task[0] cannot have signals
	cmpl _task,%eax
	je 3f
    ...
    ...
```

在`system_call`函数中也会先将一些寄存器的值压栈，然后将`%ds,%es`置为`$0x10`，也就是内核数据段段选择子，将`%fs`置为`$0x17`，也就是当前LDT表中的第三项即当前进程的用户态数据段。下图是当前内核栈分布：

![img](https://img-blog.csdnimg.cn/20201212202228815.png)

接着执行对应的系统调用函数，我们这里是sys_fork。

```c
.align 2
_sys_fork://fork的系统调用
	call _find_empty_process//调用这个函数
	testl %eax,%eax
	js 1f
	push %gs
	pushl %esi
	pushl %edi
	pushl %ebp
	pushl %eax
	call _copy_process//
	addl $20,%esp
1:	ret
```

执行完` _find_empty_process`函数后（这个没什么好说的），又进行了一些压栈，然后调用`copy_process`函数

```c
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
		long ebx,long ecx,long edx,
		long fs,long es,long ds,
		long eip,long cs,long eflags,long esp,long ss){}
```

一一对比可以看出，此时内核栈中数据均作为copy_process的参数，具体图就不画了。通过执行`addl $20,%esp`让esp跳转到指向`system_call`的下一句指令地址处。通过ret弹栈跳转到对应位置继续执行`system_call`代码。后续所做的是判断基于当前进程的信息判断是否发生进程的调度。这里非常关键，一个重要的理解是如果当前需要发生进程的调度，那么当前进程就会切换到下一个进程，而一定会存在一个时刻又切 回到当前进程。我们假设发生了进程调度

```c
.align 2
reschedule:
	pushl $ret_from_sys_call
	jmp _schedule
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201212214657327.png)

现在调用schedule()函数进行进程调度。

```c
schedule(){
……
switch_to(pnext,_LDT(next));
}
```

调用`switch_to`进行进程切换。有参数入栈以及返回地址入栈

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201212214619938.png)

进入`switch_to`，首先进行函数调用的相关准备工作

```c
switch_to:
        pushl %ebp
        movl %esp,%ebp
        pushl %ecx
        pushl %ebx
        pushl %eax
```

![img](https://img-blog.csdnimg.cn/20201212214552877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajE1OTczNzQwMzQ=,size_16,color_FFFFFF,t_70)

`switch_to`是需要我们魔改的关键函数，我们假设我们已经修改完毕，那么进程切换之后就跳转到另一个进程的内核栈。与当前进程的内核栈具有相同的分布（这是一定的，因为大家都是在相同情况下切换到了另一个进程）。我们在`switch_to`所进行的关键操作就是内核栈的切换也即esp的切换（不知道为什么不切换ss）。**这里有一个非常关键的理解就是进程的切换就发生在switch_to的push和pop中，换句话说switch_to函数中push操作完成之后就是进程切换前应该有的样子，也是进程创建的时候应该有的样子。**内核栈就记录了进程的信息，但是指令执行序列并未切换，仍然接着继续进行（指令执行序列的切换是在返回用户栈的时候完成的）。我们假设存在一个时间从某一个进程又切换回到了当前进程，也就是说当前栈指针指向的仍然是上面的那个内核栈

```c
switch_to:
……
1:  popl %eax
	popl %ebx
	popl %ecx
	popl %ebp
ret
```

在`switch_to`中执行ret弹出返回地址，弹出两个参数，跳转回schedule()继续执行（switch_to是schedule中的最后一句代码），对应应该执行`}`也就是ret，弹出返回地址`$ret_from_sys_call`，跳转到对应位置执行。

```c
ret_from_sys_call:
	……
3:      popl %eax
        popl %ebx
        popl %ecx
        popl %edx
        pop %fs
        pop %es
        pop %ds
        iret
```

这里弹出的也就是`system_call`刚开始压入的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201212221504182.png)

最后执行iret进行中断返回，切回到对应进程的用户栈上。

## 具体的代码的修改

### switch_to的修改

switch_to所作的事情如下：

- 判断要切换的进程和当前进程是否是同一个进程
- 切换PCB(task_struct)
- TSS中的内核栈指针的重写
- 切换内核栈
- 切换LDT
- 重置一下用户态内存空间的选择符fs

```c

.align 2
switch_to:

    
	pushl %ebp
	movl %esp,%ebp
	pushl %ecx
	pushl %ebx
	pushl %eax

	# (1)判断要切换的进程和当前进程是否是同一个进程
	movl 8(%ebp),%ebx	/*%ebp+8就是从右往左数起第二个参数，也就是*pnext*/
	cmpl %ebx,current	/* 如果当前进程和要切换的进程是同一个进程,就不切换了 */
	je 1f
	/*先得到目标进程的pcb，然后进行判断
    如果目标进程的pcb(存放在ebp寄存器中) 等于   当前进程的pcb => 不需要进行切换，直接退出函数调用
    如果目标进程的pcb(存放在ebp寄存器中) 不等于 当前进程的pcb => 需要进行切换，直接跳到下面去执行*/


	# (2)切换PCB
	movl %ebx,%eax
	xchgl %eax,current
	/*ebx是下一个进程的PCB首地址，current是当前进程PCB首地址*/


	# (3)TSS中的内核栈指针的重写
	movl tss,%ecx		/*%ecx里面存的是tss段的首地址，在后面我们会知道，tss段的首地址就是进程0的tss的首地址，
	根据这个tss段里面的内核栈指针找到内核栈，所以在切换时就要更新这个内核栈指针。也就是说，
	任何正在运行的进程内核栈都被进程0的tss段里的某个指针指向，我们把该指针叫做内核栈指针。*/
    addl $4096,%ebx           /* 未加4KB前，ebx指向下一个进程的PCB首地址，加4096后，相当于为该进程开辟了一个“进程页”，ebx此时指向进程页的最高地址*/
    movl %ebx,ESP0(%ecx)        /* 将内核栈底指针放进tss段的偏移为ESP0（=4）的地方，作为寻找当前进程的内核栈的依据*/
	/* 由上面一段代码可以知道们的“进程页”是这样的，PCB由低地址向上扩展，栈由上向下扩展。
	也可以这样理解，一个进程页就是PCB，我们把内核栈放在最高地址，其它的task_struct从最低地址开始扩展*/


	# (4)切换内核栈
	# KERNEL_STACK代表kernel_stack在PCB表的偏移量，意思是说kernel_stack位于PCB表的第KERNEL_STACK个字节处，注意:PCB表就是task_struct
	movl %esp,KERNEL_STACK(%eax)	/* eax就是上个进程的PCB首地址，这句话是将当前的esp压入旧PCB的kernel_stack。所以该句就是保存旧进程内核栈的操作。*/
	movl 8(%ebp),%ebx		/*%ebp+8就是从左往右数起第一个参数，也就是ebx=*pnext ,pnext就是下一个进程的PCB首地址。至于为什么是8，请查看附录(I)*/
	movl KERNEL_STACK(%ebx),%esp	/*将下一个进程的内核栈指针加载到esp*/


	# (5)切换LDT
	movl 12(%ebp),%ecx         /* %ebp+12就是从左往右数起第二个参数，对应_LDT(next) */
	lldt %cx                /*用新任务的LDT修改LDTR寄存器*/
	/*下一个进程在执行用户态程序时使用的映射表就是自己的 LDT 表了，地址空间实现了分离*/

	# (6)重置一下用户态内存空间指针的选择符fs
	movl $0x17,%ecx
	mov %cx,%fs
	/*通过 fs 访问进程的用户态内存，LDT 切换完成就意味着切换了分配给进程的用户态内存地址空间，
	所以前一个 fs 指向的是上一个进程的用户态内存，而现在需要执行下一个进程的用户态内存，
	所以就需要用这两条指令来重取 fs。但还存在一个问题，就是为什么固定是0x17呢?详见附录(II)*/
	

# 和后面的 clts 配合来处理协处理器，由于和主题关系不大，此处不做论述
    cmpl %eax,last_task_used_math
    jne 1f
   clts


1:  popl %eax
	popl %ebx
	popl %ecx
	popl %ebp
ret
```
