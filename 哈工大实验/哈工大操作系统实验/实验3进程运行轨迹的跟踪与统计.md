# 实验3进程运行轨迹的跟踪与统计

## 实验目的

- 掌握 Linux 下的多进程编程技术；
- 通过对进程运行轨迹的跟踪来形象化进程的概念；
- 在进程运行轨迹跟踪的基础上进行相应的数据统计，从而能对进程调度算法进行实际的量化评价，更进一步加深对调度和调度算法的理解，获得能在实际操作系统上对调度算法进行实验数据对比的直接经验。

整个实验流程并不复杂，首先创建process.log文件，然后在`kernel/printk.c`文件中实现fprintk函数（基于进程的状态以及运行时间向某个文件流中打印一定信息），这个函数我们暂时不要求撰写。接着我们要找到内核代码中进程发生状态切换的位置，然后调用fprintk函数将进程信息打印到process.log文件中。在这个过程中注意对头文件的引入以及对MakeFile文件的修改。最后撰写process.c代码（按照我们的想法进行进程的调度，即多进程编写）。

## 提前读Log文件

我们将对标准输入输出的打开放到进程0中进行，同时打开我们的process.log文件

```c
move_to_user_mode();
	setup((void *) &drive_info);

	/* for visiting log document in prc0 in advance 
	这是后面加进去的*/
	(void) open("/dev/tty0",O_RDWR,0);
	(void) dup(0);
	(void) dup(0);
	(void) open("/var/process.log",O_CREAT|O_TRUNC|O_WRONLY,0666);
	/*这上面部分是需要添加的*/
	
	if (!fork()) {		/* we count on this going ok */
		init();
	}

```

## fprintf函数

```c
/*
 *  linux/kernel/printk.c
 *
 *  (C) 1991  Linus Torvalds
 */

/*
 * When in kernel-mode, we cannot use printf, as fs is liable to
 * point to 'interesting' things. Make a printf with fs-saving, and
 * all is well.
 */
#include <stdarg.h>
#include <stddef.h>
#include <linux/kernel.h>

/*之后添加进去的*/
#include "linux/sched.h"
#include "sys/stat.h"
/*之后添加进去的*/

static char buf[1024];

/*之后添加进去的*/
static char logbuf[1024];
/*之后添加进去的*/

extern int vsprintf(char * buf, const char * fmt, va_list args);

int printk(const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
	i=vsprintf(buf,fmt,args);
	va_end(args);
	__asm__("push %%fs\n\t"
		"push %%ds\n\t"
		"pop %%fs\n\t"
		"pushl %0\n\t"
		"pushl $buf\n\t"
		"pushl $0\n\t"
		"call tty_write\n\t"
		"addl $8,%%esp\n\t"
		"popl %0\n\t"
		"pop %%fs"
		::"r" (i):"ax","cx","dx");
	return i;
}

/*之后添加进去的*/
int fprintk(int fd, const char *fmt, ...)
{
    va_list args;
    int count;
    struct file * file;
    struct m_inode * inode;

    va_start(args, fmt);
    count=vsprintf(logbuf, fmt, args);
    va_end(args);
    if (fd < 3)
    {
        __asm__("push %%fs\n\t"
            "push %%ds\n\t"
            "pop %%fs\n\t"
            "pushl %0\n\t"
            "pushl $logbuf\n\t"
            "pushl %1\n\t"
            "call sys_write\n\t"
            "addl $8,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (count),"r" (fd):"ax","cx","dx");
    }
    else
	{
        if (!(file=task[0]->filp[fd]))
            return 0;
        inode=file->f_inode;

        __asm__("push %%fs\n\t"
            "push %%ds\n\t"
            "pop %%fs\n\t"
            "pushl %0\n\t"
            "pushl $logbuf\n\t"
            "pushl %1\n\t"
            "pushl %2\n\t"
            "call file_write\n\t"
            "addl $12,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (count),"r" (file),"r" (inode):"ax","cx","dx");
    }
    return count;
}
/*之后添加进去的*/

```

## 寻找状态切换点

‘N’ ‘J’ ‘R’ ‘W’ ‘E’ 符号含义

X 可以是 N、J、R、W 和 E 中的任意一个，分别表示进程新建(N)、进入就绪态(J)、进入运行态®、进入阻塞态(W) 和退出(E)；

所有关于进程的操作在`sched.c fork.c exit.c`这些文件中。

## MakeFile文件的修改

先简要对MakeFIle语法做一个介绍

基本格式：

目标：该目标依赖的其他目标

​	产生该目标要执行的命令（有的目标存在，有的目标不存在）

### 规则

1.如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。

2.如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。

3.如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。

4.某个c文件的引用了更多或者更少的头文件，那么此c文件对其他文件的依赖需要进行修改

- 反斜杠代表换行
- 一个命令以tab开头
- make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。
- make clean删除执行文件和所有的中间目标文件，重新进行make

### 报错

注意make命令执行过程中我们经常会看到

`Entering director ...`或者`Leaving directory`。这是make在执行过程中进行目录切换的信息。在这个过程中执行的命令也会展现出来。

___

对于我们当前情况来说，我们在`kernel/ptintk.c`中编写了fprintk函数，需要我们引入几个头文件，因此在kernel目录下的MakeFile中，我们需要对printk.s printk.o 的依赖文件进行添加。

```c
printk.s printk.o: printk.c ../include/stdarg.h ../include/stddef.h \
  ../include/linux/kernel.h \

/*之后添加的部分*/
  ../include/linux/sched.h \
  ../include/sys/stat.h
/*之后添加的部分*
```

另外我们新增的函数fprintk需要进行声明，kernel下的函数在 **`/include/linux/kernel.h`** 中进行声明。

## 编译启动

在Linux-0.11下编译之后，在oslab下启动操作系统，运行一段时间后，sync**向磁盘同步输入 防止文件未被写入**，然后退出操作系统后，将Linux-0.11中的process.log文件copy出来。