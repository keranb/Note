# 实验2系统调用

要知道，我们的操作系统就是用来管理硬件资源的。操作系统为用户提供了很多系统调用接口函数，用户通过这些系统调用可以进入操作系统进而通过操作系统使用计算机硬件资源。这些系统调用接口函数是被应用程序所调用，所以并不属于内核代码的一部分。

在进行实验之前，我们先从用户应用程序角度浏览一段整段旅程。

## 系统调用发生了什么

倘若我们使用某个应用程序在界面上显示一段内容，他内在的代码逻辑一定是调用了printf()函数（我们假设此应用是用c语言编写的，工作在Linux操作系统上）。第一阶段的工作是由库函数完成的，库函数对格式化输出中的格式进行处理，然后调用**write系统调用**真正使用屏幕进行输出。系统调用接口函数都是通过宏展开进行定义的。在`linux-0.11/include/unistd.h`中定义了`_syscall0,\_syscall1,\_syscall2`之类的宏，分别代表无参数，一个参数，两个参数的系统调用接口函数。使用这些宏能够非常轻松的定义我们的系统调用接口函数。我们以`_syscall3`为例来看看这些宏的定义。

```c
#define _syscall3(type,name,atype,a,btype,b,ctype,c)
type name(atype a,btype b,ctype c) {
    long __res;
    //内嵌汇编
    __asm__("int 0x80"
           :"=a"(__res):""(__NR_##name),"b"((long)(a)),"c"((long)(b)),
           "d"((long)(c)));
    if (__res > 0) return (type) __res;
    errno = -__res;
    return -1;
}
```

这是一段c代码，内嵌了一段汇编。对于内嵌汇编来说，第一个冒号后面接的是输出寄存器，第二个冒号后面接的是输入寄存器。那这段内嵌汇编所作的工作就是，首先接收参数，参数a以长整形类型（32位机4个字节）存入`%ebx`寄存器，参数b以长整形类型存入`%ecx`寄存器，参数c以长整形类型存入`%edx`寄存器，**将`(__NR_##name)`以立即数的形式存入`%eax`寄存器。执行`int 0x80`中断**。最后将`%eax`寄存器中的值存入__res寄存器变量中。

我们再来看看write系统调用接口函数的定义

```c
_syscall3(int,write,int,fd,char*,buf,int,count);
```

ok，现在我们可以明白了，当我们将系统调用接口函数进行宏展开后你会发现最关键的地方就在`int 0x80`。而系统调用函数接口函数调用`int 0x80`中断的目的就是为了进入操作系统（内核）。那为何可以进入内核？

`int 0x80`作为一个中断，一定会进行跨段的jmp跳转（对于`int 0x80`来说肯定是跳转到内核的某个段）。这个时候cpu发现需要进行特权级检查，cpu会取出两个重要的数值CPL（当前特权级），DPL（目标特权级）。CPL由CS寄存器的后两位给出（这是很自然的，因为CS寄存器就决定了当前指令执行在哪个段）。对于中断来说，与一般的指令执行不同，中断查询的是IDT表。由IDT表来确定DPL，对于内核段内存区域来说，查询的是GDT，对于用户段内存区域来说，查询的是LDT。![在这里插入图片描述](https://img-blog.csdnimg.cn/4ed860c1a3f0454a8ebb945fda8e1a7b.png)

IDT表在系统开机时，执行到main.c函数时候就完成了初始化。

```c
void main(void) {
//	...
    time_init();
    sched_init();
    buffer_init(buffer_memory_end);
//	...
}
```

`sched_init()`在`kernel/sched.c`中定义为

```c
void shced_init(void) {
//	...
    set_system_gate(0x80,&system_call);
}
```

`set_system_gate` 是个宏，在 `include/asm/system.h` 中定义为：

```c
#define set_system_gate(n,addr) \
    _set_gate(&idt[n],15,3,addr)
```

`_set_gate` 的定义是：

```c
#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ ("movw %%dx,%%ax\n\t" \
    "movw %0,%%dx\n\t" \
    "movl %%eax,%1\n\t" \
    "movl %%edx,%2" \
    : \
    : "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
    "o" (*((char *) (gate_addr))), \
    "o" (*(4+(char *) (gate_addr))), \
    "d" ((char *) (addr)),"a" (0x00080000))
```

当你看懂了这段代码之后你就可以明白，这里所做的就是填写IDT，将 `system_call` 函数地址写到 `0x80` 对应的中断描述符中，也就是在中断 `0x80` 发生后，自动调用函数 `system_call`。要注意的是，填写IDT的时候将DPL置为3。将这里与前面联系起来，当前系统调用接口函数触发`int 0x80`中断后进行特权级检查，CPL=3,DPL=3。检查通过，继续执行。中断处理是要跳到另一段程序去执行，即修改PC。具体是修改CS:EIP，所以现在会从IDT表项中取出信息设置`CS=0x0008,EIP=system_call = system_call`函数的入口地址。由于此时`CS`被设置为`0x0008`，那么现在的CPL变成了0，也就是说我们就此进入了内核，可以在内核随意访问。

接下来执行`system_call`函数，该函数纯汇编打造，定义在 `kernel/system_call.s` 中

```tex
!……
! # 这是系统调用总数。如果增删了系统调用，必须做相应修改
nr_system_calls = 72
!……

.globl system_call
.align 2
system_call:

! # 检查系统调用编号是否在合法范围内
    cmpl \$nr_system_calls-1,%eax
    ja bad_sys_call
    push %ds
    push %es
    push %fs
    pushl %edx
    pushl %ecx

! # push %ebx,%ecx,%edx，是传递给系统调用的参数
    pushl %ebx

! # 让ds, es指向GDT，内核地址空间
    movl $0x10,%edx
    mov %dx,%ds
    mov %dx,%es
    movl $0x17,%edx
! # 让fs指向LDT，用户地址空间
    mov %dx,%fs
    call sys_call_table(,%eax,4)
    pushl %eax
    movl current,%eax
    cmpl $0,state(%eax)
    jne reschedule
    cmpl $0,counter(%eax)
    je reschedule
```

`system_call`所做的很简单，就是将`%ds,%es,%fs`三个段寄存器入栈保存。我们是从用户段通过系统调用接口函数产生中断进入到`system_call`函数，在这个过程中并未修改上述三个段寄存器的值，因此此时仍然指向用户态内存。而进入到`systen_call`这里之后，我们就进入了内核，我们让让ds, es指向GDT内核地址空间，让fs指向LDT用户地址空间。是因为我们有可能需要访问用户地址空间。然后我们就调用了`sys_call_table`函数数组一定偏移对应的一个函数。

在这里，有几个问题需要讨论：

1.为什么可以通过call去调用对应的那个函数

这是因为**`system_call`函数定义在kernel目录下（也必须定义在kernel目录下），我们真正需要调用的函数比如说`sys_write`也定义在kernel目录下**，那么在内核刚加载的时候，这些代码的可执行文件就被加载到了内存中。那么我们一定可以通过call取调用。

2.如何传递参数

汇编与c之间的相互调用，关键就是明白参数到底是如何传递的。我们将`%ebx,%ecx,%edx`以反序的形式压入到栈中就起到了传递参数的作用。

3.注意`system_call`函数会检查系统调用编号是否在合法范围内。

4.`call sys_call_table(,%eax,4)` 

根据汇编寻址方法它实际上是：`call sys_call_table + 4 * %eax`，其中 eax 中放的是系统调用号（在系统调用接口函数中存入eax中的），即 `__NR_xxxxxx`。显然，`sys_call_table` 一定是一个函数指针数组的起始地址，它定义在 `include/linux/sys.h` 中：

```
fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,...
```

## 实验步骤

实验要求我们新增两个系统调用iam()和whoami()。这里分为内核和用户两个层面考虑。

**首先，对于内核层面，我们需要做的是：**

1.在`system_call.s`文件中增加系统调用数

```c
nr_system_calls = 74
```

2.在`sys_call_table`数组中添加对应的系统调用函数（假设已经写好了）

同时需要从外部引入。

![请添加图片描述](https://img-blog.csdnimg.cn/fb574c53501c4aeeb33208dd191eb06e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn54aK54ix5bmy5rS7,size_20,color_FFFFFF,t_70,g_se,x_16)

3.修改`include/unistd.h`,在其中添加两个系统调用号![请添加图片描述](https://img-blog.csdnimg.cn/c2a76335f0f5476798ae0ec3d960c03e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn54aK54ix5bmy5rS7,size_20,color_FFFFFF,t_70,g_se,x_16)

4.在kernel目录下创建who.c文件，在其中实现两个系统调用函数iam(),whoami()。

```c
/*
 * 函数sys_iam()和sys_whoami()的实现
 */

#include <unistd.h>			
#include <asm/segment.h>	/*get_fs_byte() put_fs_byte()函数调用的头文件*/
#include <errno.h>			/*错误代码 EINVAL等要用到*/
#include <string.h>			/*C语言字符串处理头文件*/

/*实现方式1:(自己写的)*/
char kernelchars[23];
int sys_iam(char *name)
{
	char temp[30];
	int counter = 0;

	for (; counter < 30; counter++)
	{                                                
        temp[counter] = get_fs_byte(&name[counter]); 
        if (temp[counter] == '\0')   break;
	}

	if (counter >= 23)
	{
		errno = EINVAL;
		return -1;
	}
	strcpy(kernelchars, temp); 
	return counter + 1;        
}

/*
 * 功能：将内核中由iam()保存的字符串读取出来，保存到name指向的用户空间(该用户空间应预留'\0'的位置)，同时确保不会对name访问越界
 * 返回值：复制的字符数,包含'\0'
 * 若size小于需要的空间，则返回-1，并设置errno=EINVAL
 */

int sys_whoami(char * name, unsigned int size)
{
    int len = 0;
    for (;msg[len] != '\0'; len++);
    
    if (len > size) 
    {
        return -(EINVAL);
    }
    
    int i = 0;
    for(i = 0; i < size; i++)
    {
        put_fs_byte(msg[i], name+i);
        if(msg[i] == '\0') break;
    }
    return i;
}

```

要注意的是，我们定义的两个系统调用函数是在kernel目录下的who.c文件中（也必须在这个文件中），也就是说是在内核中，那么我们iam()系统调用函数的需求是将一段用户段空间的字符串复制到内核段。那么如何访问用户段空间。需要用到`get_fs_byte`和`put_fs_byte`函数，你从名字中就可以看出，它应该是通过fs寄存器进行一定的操作。

**用户层面**

我们需要定义系统调用接口函数并进行测试（也即调用系统调用接口函数完成一定功能）。如果我们调用系统调用接口函数，那么我们一定需要系统调用号，那么在用户层面也需要修改unitsd.h。通过`./mount-hdc`挂载脚本修改`hdc/usr/include/unistd.h`。在`/hdc/usr/root`下编写测试文件`test.c`。

**修改MakeFIle**

因为我们在kernel目录下新增了who.c文件，所以我们要对`kernel/MakeFile`进行修改。

![屏幕截图 2022-05-25 143503](C:\Users\可燃冰\Desktop\编程笔记\哈工大操作系统实验\images\屏幕截图 2022-05-25 143503.png)

在linux-0.11目录下编译 make all。

在oslab下运行 ./run。进入bochs后，对test.c编译得到可执行文件后，执行之后可得到测试结果。