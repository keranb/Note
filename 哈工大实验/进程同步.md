# 进程同步

进程同步就是通过对进程走走停停（等待和唤醒）的控制来让多个进程步调一致，合理有序地向前推荐，完成相互依赖，相互合作。

## 由信号到信号量

每个进程都有自己要完成的工作，即要执行的程序。因为多个进程之间存在着依赖关系，所以进程不能一直执行自己的工作，需要在适当的时候查看其他进程的工作情况，然后根据结果来决定自己是否继续工作。

一个很自然的想法是进程在某个需要的地方基于其他进程的工作状态来决定是否进行休眠；在另一个需要的地方唤醒其它相关的休眠进程。这里举一个具体的例子，即生产者消费者的例子。多个进程共享一个缓冲区，生产者需要往共享缓冲区放内容，消费者需要往共享缓冲区去内容，当缓冲区满的时候生产者进程需要等待消费者取走内容；当缓冲区空的时候消费者进程需要等待生产者放内容。

基于**信号**的概念，我们给出生产者消费者问题的解决方法

```c
// 生产者Producer
while(true){
	if (counter == BUFFER_SIZE){
        sleep_on(empty);
    }
    buffer[in] = item;
    in = (in + 1) % BUFFER_SIZE;
    counter++;
    if (counter == 1){
        wake_up(full);
    }
}

// 消费者Consumer
while(true){
	if (counter == 0){
        sleep_on(full);
    }
    buffer[in] = item;
    in = (in - 1) % BUFFER_SIZE;
    counter--;
    if (counter == BUFFER_SIZE-1{
        wake_up(empty);
    }
}
```

我们这里定义了两个信号`empty,full`，empty是用来针对生产者进程，当生产者想要往缓冲区放内容的时候需要先看看当前缓冲区是否是满的，如果是满的，那么生产者进程就要进入休眠；如果不是满的，那么就可以向缓冲区中放一个内容，同时对counter++表明缓冲区中多了一个内容。这个时候，生产者还需要判断当前缓冲区内容是否为1，若为1说明在当前生产者进程放内容之前缓冲区是空的，也就表明可能存在消费者进程处于休眠状态，通过full信号量进行唤醒。将那些因为full休眠的消费者进程唤醒。（注意这里的full与其本身的含义有所不同）

### 信号量的引入

基于信号，我们似乎可以很好的解决问题，来看看这样一个情况。当前缓冲区满，有两个生产者进程P1和P2都亟待执行，当前这两个生产者进程都会进入休眠状态。有一个消费者进程C开始执行，在缓冲区中产生了一个空位，倘若先调度到生产者进程P1执行，P1被唤醒。此时若消费者进程继续执行又产生一个空位（在P1生产一个内容之前），按理来说此时应该唤醒P2，但是counter==BUFFER_SIZE-1没法唤醒P2。这就出现了一个问题：当有多个进程休眠时我们没办法做多合理唤醒。引出信号量的概念：让信号具备一定的信息。

比方说对于empty信号量，当缓冲区满的时候empty=0，有两个生产者进程P1和P2都亟待执行，此时不仅仅让生产者进程进入休眠状态同时让empty--，消费者基于empty的值进行判断，若empty<0说明存在休眠的生产者进程。生产者唤醒一次让empty+1，再次执行的时候发现empty仍<0，继续唤醒同时让empty+1。这样两个生产者进程都能被合理的唤醒。

具体运用在生产者消费者实例：

```c
struct semaphore
{
    int value;
    PCB queue; // 等待在该信号量上的进程队列
}

// 对消费者来说初始状态没有一个内容可供使用
semaphore full = 0;
// 对生产则来说初始状态有BUFFER_SIZE个空位可使用
semaphore empty = BUFFER_SIZE;
semaphore mutex = 1;

// 生产者Producer
while(true){
    P(empty);
    P(mutex);
    buffer[in] = item;
    in = (in + 1) % BUFFER_SIZE;
    V(mutex);
    V(full);
}

// 消费者Consumer
while(true) {
    P(full);
    P(mutex);
    item = buffer[out];
    in = (in - 1) % BUFFER_SIZE;
    V(mutex);
    V(empty);
}
```

mutex信号量用于对缓冲区进行保护，确保同一时间只能有一个进程修改缓冲区。

倘若两个生产者进程同时进入，执行`buffer[in] = item`就会带来问题。

## 信号量临界区保护

信号量的作用就是根据信号量数值表达出来的语义来决定进程的停与走。因此，信号量的数值非常重要，只有信号量的数值与信号量对应的语义信息保持一致，才能正确的使用信号量来决定进程的同步。由于同时存在于操作系统中的多个并发进程会竞争使用CPU，竞争会带来各种各样的调度结果，有些调度顺序很可能导致共享变量出现语义错误。

以empty信号量为例

```c
// 初始情况
empty = -1;

// 生产者P1
P1.register = empty;
P1.register = P1.register - 1;
empty = P1.register;

// 生产者P2
P2.register = empty;
P2.register = P2.register - 1;
empty = P2.register;

// 可能产生的调度调度执行序列
P1.register = empty;
P1.register = P1.register - 1;
P2.register = empty;
P2.register = P2.register - 1;
empty = P1.register;
empty = P2.register;
```

初始情况empty=-1，来了两个生产者，empty的正确取值应该是-3，但是上述可能的执行序列最后empty=-2。产生的原因就是empty--作为一个高级语言上的操作，在底层汇编代码需要多条指令执行所以一旦发生进程调度就有可能出现这种情况。解决的办法是我们希望empty--作为一个完整的操作进行，执行的时候不会被其它进程抢占（我们称这样的操作为原子操作）。针对信号量empty的操作我们称之为临界区，即一次最多只能有一个进程进入（互斥进入）。

临界区需要满足以下几点要求：

- 互斥进入
- 有空让进（如果没有进程处于临界区同时有进程请求进入临界区，则应该能让该进程进入临界区）
- 有限等待

### 临界区的软件操作

#### 轮换法

```c
// 生产者P0
while (trun == 1);
empty--;
trun = 1;

// 生产者P1
while (trun == 0);
empty--;
trun = 0;
```

轮换法存在的问题是：

倘若当前turn=1,轮到生产者P1进程，进入P1进程后在执行turn=0之前就退出了，那么P0就无法进入临界区。

#### 标记法

```c
// 生产者P0
flag[0] = true;
while(flag[1]);
empty--;
flag[0]=false;

// 生产者P1
flag[1] = true;
while(flag[0]);
empty--;
flag[1]=false;
```

标记法也能满足互斥进入，但存在的一个问题是：

倘若两个进程同时进入临界区，会都进入死循环，谁也没法进入临界区。

#### Peterson算法

结合轮换法和标记法

标记法的缺点就是当两个进程都要进入临界区的时候会相互锁住。如果我们让这两个进程存在一定的优先级，那是不是就可以解决我们的问题了

```c
// 生产者P0
flag[0] = true;
turn = 1;
while(flag[1]&&turn == 1);
empty--;
flag[0]=false;

// 生产者P1
flag[1] = true;
turn = 0;
while(flag[0]&&turn == 0);
empty--;
flag[1]=false;
```

#### Lamport算法

Peterson算法只能处理两个进程的临界区，Lamport能解决多个进程的临界区。将临界区控制问题类比为多个顾客区面包点采购的问题，面包店一次只能接纳一位顾客采购。面包店的做法是：N个顾客要进入面包店采购，首先按照次序给每个顾客安排一个号码，顾客按照其号码从小到大依次购买，完成购买的顾客号码被重置为0，这样完成购买的顾客如果要再次购买就必须重新排队。

```c
do
{
    choosing[i] = true;
    number[i] = max(number[0],number[1],...,number[n]) + 1;
    choosing[i] = false;
    for (j = 0 ;j < n; j++){
        while(choosing[j]);
        while((number[j] != 0)&&(number[j],j) < (number[i],i));
    }
	.....// 临界区代码
    number[i] = 0;
}while(true);
```

choosing[i]表示该进程是否收到标号；从所有标号中找一个最大的，然后加一赋给number[i]。对所有进程进行一个遍历（包含当前i进程），第一个while循环使j进程收到标号之后才退出循环；第二个while循环可以这么去理解：有两种情况会进行死循环：1.number[j]!=0且number[j]<number[i]，即j进程存在标号且标号小于i进程，那么就不会退出while循环让你的i进程进入临界区。2.number[j]=number[i]且j<i，即j进程标号与i进程相同但是j<i，不退出while循环让你的i进程进入临界区。

### 临界区的硬件操作

对于只有一个CPU的计算机，如果在进程进入临界区以后能够阻止调度，即不让系统发生调度，就能够实现临界区。而CPU的调度往下深究就是由于中断产生的，所以如果我们能够在进程进入临界区之前关中断，在出临界区的时候开中断，就能够解决我们的问题。

对于多CPU就没办法通过开关中断来完成了，我们可以定义一个保护临界区的互斥信号量lock，注意对于该信号量的P,V操作必须是原子性的，我们可以使用硬件指令TestAndSet。

```javascript
function TestAndSet(boolean &lock) {
    boolean initial = *lock;
    *lock = true;
    return initial;
}
```





## 信号量的代码实现

