# 操作系统引导与启动

> 涉及boot目录下的`bootsect.s`，`setup.s`，`system.s`文件

![屏幕截图 2022-06-12 111449](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-06-12 111449.png)

首先，看一下过程概览。

当PC的电源打开后，80x86结构的CPU将自动进入实模式，并从地址0xFFFF0开始自动执行程序代码，这个地址通常是ROM-BIOS中的地址。PC机的BIOS将执行某些系统的检测，并在物理地址0处开始执行初始化中断向量。此后，它可将**启动设备**的第一个扇区（磁盘引导扇区，512字节）读入内存绝对地址0x7C00处，并跳转到这个地方。启动设备通常是软驱或是硬盘。当从0x7C00处执行时会把自己移动到内存绝对地址0x90000处，并把启动设备中后2KB字节码代码读入到内存0x90200处，而内核的其他部分（system模块）则被读入到从内存地址0x10000开始处。

![屏幕截图 2022-06-12 110311](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-06-12 110311.png)

因为当时system模块的长度不会超过0x80000字节大小（即512KB），所以bootsect程序把system模块读入物理地址0x10000开始位置处时并不会覆盖在0x90000（576KB）处开始的bootsect和setup模块。后面setup程序将会把system模块移动到物理内存起始位置处，这样system模块中代码的地址也即等于实际的物理地址，便于对内核代码和数据进行操作。在系统加载期间将显示信息“Loading...”。然后将控制权传递给`boot/setup.s`中的代码。bootsect的代码为什么不把系统模块直接加载到物理内存0x0000开始处而要在setup中再进行移动呢？这是因为在随后执行的setup代码开始部分还需要利用ROM BIOS中的中断调用来获取机器的一些参数。

![屏幕截图 2022-06-12 110336](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-06-12 110336.png)

另外，仅在内存中加载了上述内核代码模块并不能让Liux系统运行起来。作为完整可运行的Liux系统还需要有一个基本的文件系统支持，即根文件系统。Liux0.11内核仅支持MNX的1.0文件系统。根文件系统通常是在另一个软盘上或者在一个硬盘分区中。为了通知内核所需要的根文件系统在什么地方，bootsect..s程序的第43行上给出了根文件系统所在的默认块设备号。

## bootsect.s

在bootsect代码执行期间，它会将自己移动到内存绝对地址0x90000处并继续执行。该程序的主要作用是首先把第2个扇区开始的4个扇区的setup模块加载到内存紧接着bootsect后面位置处（0x90200），然后利用BIOS中断0x13取磁盘参数表中当前启动引导盘的参数，接着在屏幕上显示"Loding system..."字符串。再把磁盘上setup模块后面的system模块加载到内存0x10000开始的地方。随后确定根文件系统的设备号，若没有指定，则根据所保存的引导盘的每磁道扇区判别出盘的类型和种类并保存其设备号于root_dev(引导块的508地址处)，最后长条船到setup程序的开始处（0x90200）执行setup程序。

下图给出了Linux0.11内核在1.44MB磁盘上所占扇区的分布情况。1.44MB磁盘共有2880个扇区，其中引导程序代码占用第1个扇区，setup模块占用随后的4个扇区，而0.11内核system模块大约占随后的240个扇区。还剩下2630多个扇区未被使用。这些剩余的未用空间可被利用来存放一个基本的根文件系统，从而可以创建出使用单张磁盘就能让系统运转起来的集成盘来。![屏幕截图 2022-06-12 112851](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-06-12 112851.png)

接下来对具体的代码进行分析。我们只挑关键部分略读。

**首先，进行了一些符号常量的赋值。**

```
SYSSIZE = 0X3000
ROOT_DEV = 0X306
```

`SYSSIZE`代表要加载的系统模块的长度，当该值为0x8000时，表示内核最大为512KB

`ROOT_DEV`给出根文件系统的设备号。若该值为0x000代表根文件系统设备使用与引导时同样的软驱设备。若该值为0x306代表根文件系统在第二个硬盘的第一个分区。其中，设备号的具体含义如下：

设备号 = 主设备号*256 + 次设备号（主设备号：1-内存，2-磁盘，3-硬盘，4-ttyx，6-并行口，7-非命名管道）

- 0x300 - /dev/hd0  - 代表整个第一个硬盘
- 0x301 - /dev/hd1 - 代表第一个硬盘的第一个分区
- ...
- 0x304 - /dev/hd4 - 代表第一个硬盘的第四个分区
- 0x305 - /dev/hd5 - 代表整个第二个硬盘
- 0x306 - /dev/hd6 - 代表第二个硬盘的第一个分区

**然后，将当前程序代码也就是0x7c00处的代码移动到0x90000处，并从0x90000处开始执行。**

注意它是如何实现的：

```c
mov	ax,#BOOTSEG
	mov	ds,ax
	mov	ax,#INITSEG
	mov	es,ax
	mov	cx,#256
	sub	si,si
	sub	di,di
	rep
	movw
	jmpi	go,INITSEG
go:	mov	ax,cs
```

接着，进行部分寄存器的初始化后，正式实现bootsect的功能。第一个就是将引导扇区中bootsect模块后面的4个扇区也就是**setup模块加载到0x90200处。**

```c
go:	mov	ax,cs
	mov	ds,ax
	mov	es,ax
! put stack at 0x9ff00.
	mov	ss,ax
	mov	sp,#0xFF00		! arbitrary value >>512
    
load_setup:
	mov	dx,#0x0000		! drive 0, head 0
	mov	cx,#0x0002		! sector 2, track 0
	mov	bx,#0x0200		! address = 512, in INITSEG
	mov	ax,#0x0200+SETUPLEN	! service 2, nr of sectors
	int	0x13			! read it
	jnc	ok_load_setup		! ok - continue
	mov	dx,#0x0000
	mov	ax,#0x0000		! reset the diskette
	int	0x13
	j	load_setup

ok_load_setup:
```

然后，**读取磁盘驱动器的参数**，特别是每道的扇区数量（每道的扇区数量是相同的）

取磁盘驱动器参数INT 0x13调用格式和返回信息如下：

ah = 0x08 dl = 驱动器号（如果是硬盘则要置位7为1）

返回信息：

如果出错则CF置位，并且ah = 状态码

ah=  0，al = 0，	bl = 驱动器类型

ch = 最大磁道号的底8位  cl = 每磁道最大扇区数（位0 - 5），最大磁道号高2位（位6 - 7）

dh = 最大磁头数	dl = 驱动器数量

es:di  软驱磁盘参数表

```c
	mov	dl,#0x00
	mov	ax,#0x0800		! AH=8 is get drive parameters
	int	0x13
	mov	ch,#0x00
	seg cs
	mov	sectors,cx		#将结果放在sectors字段处
	mov	ax,#INITSEG
	mov	es,ax
```

然后，**显示信息**："Loading system"



