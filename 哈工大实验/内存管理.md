# 内存管理

内存管理就是让我们更好的使用内存，内存是用来存放数据和指令的。我们主要关注两个问题：1.`*p=7`背后到底发生了什么。2.从操作系统出发理解系统要为`*p=7`做哪些哪些内存管理工作。

对于一段c语言程序

```c
void main(void) {
    int i = 1;
}

.text
entry:
	call main
    ......
main:
	mov 1,[300]
```

首先经过编译变成一个带地址的机器指令序列，现在这个指令序列放在磁盘上。接下来这段机器指令读入到内存中，设置PC指针开始执行这段程序。将PC指针初始化为这段程序的入口地址，就是这段程序第一条指令所在的地址。第一条指令是`call main`假设main标号处的偏移为40，那这个指令其实就是`call 40`。对于这条指令来说，结果会将PC设置为40，也就是说我们应该将指令`mov 1,[300]`放在内存地址40处，这样`call 40`跳转之后才会执行main函数。但是如果将指令`mov 1，[300]`放在地位40处，那么上述程序就应该放在地址0处，但是地址0处放的是内核程序，而且操作系统是多进程视图，即使地址0处放的不是内核程序也无法满足我们的需求。

## 程序重定位

根据上面的分析我们能够看到一个很直观的问题就是对程序中逻辑地址的重定位，也就是说我们的指令或者数据不能按照程序原来的逻辑地址放在内存中，我们应该将它们在我们的管理下放在合适的地方并且建立逻辑地址与实际的内存之间的映射。

### 编译时重定位

一个想法是编译时重定位，在内存找到一个空闲区域，在编译的过程中就将程序中的逻辑地址用逻辑地址加基址替换。但是在编译时我们是没办法知道在运行的时候内存在何处是空闲的。

### 载入时重定位

我们可以在程序载入到内存的时候进行重定位，我们先找到一个内存空闲区，然后基于此进行重定位，也是将逻辑地址用逻辑地址加基址替换。这个方案确实是没什么问题的，但是我们在对内存使用的过程中存在对内存的换入与换出，那么进程换入与换出之后基址发生变化，指令的地址就不在正确了。

![屏幕截图 2022-07-10 160007](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-10 160007.png)

### 运行时重定位

上述两种想法提示我们不要将程序中的逻辑地址进行替换，它作为逻辑地址有自己应有的含义，无论什么时候我们都可以基于逻辑地址进行正确的重定位。所以我们的想法是**保留程序中的逻辑地址，在运行的时候对逻辑地址进行映射**。具体的做法是：程序载入内存执行时（及进程创建时），寻找一段空闲内存区域将程序放入，并记录下这段内存区域的基址（放在一个约定的寄存器中）。每执行一条指令，都先将指令中的逻辑地址加上基址以后才放在地址总线上。由于每条指令都需要这样的地址计算，为了提高指令执行效率，可设计硬件来快速完成地址计算过程，即MMU。因为进程是不断切换的，所以对于任意一个进程都需要记住自己的基址，很明显对于每一个进程来说都应该将基址放在自己的PCB中。进程切换时将其PCB中存放的基址取出来赋给这个CPU寄存器。

在linux.11中，我们的做法是每个进程的task_struct(PCB)中都记录着该进程的LDT表的基址，在进程切换的时候，进行LDT表的切换以及TSS的切换，也就是改变LDTR和TSSR寄存器中的值，而CS寄存器在用户态一直指向0x0f也就是LDT表的第二个描述符也即进程的代码段。也就是说在linux0.11中是使用CS寄存器与LDTR寄存器配合找到基址。

## 分段

我们提出分段的概念更好的满足上层用户需求，我所理解的是对于函数调用来说，程序中的逻辑地址对应的就是指令关于代码段的偏移，而对于变量来说，逻辑地址对应的就是关于数据段的偏移。关于段的概念在80x86实模式已做过详细介绍。

## 内存分区

我们还没有解决的一个问题是如何在内存中分割出一段空闲区域。我们需要做的是维护两个表，即空闲分区表以及已分配分区表。如果进来一个40k的长度请求，而空闲分区表中的多个空闲区域都可以满足，应该选取哪个空闲区域呢？

### 最佳适配

能够满足的最小空闲区域

### 最差适配

能够满足的最大空闲区域

## 分页

最佳适配和最差适配无论怎么样都会带来一对分散在物理内存多个位置的小区域，会造成空间浪费。解决办法是进行内存离散化，将内存分割成固定大小的片，根据请求尺寸计算出需要的小片个数。

内存分页必然会带来的是进程的内存在映射到真实的物理内存上时并不一定是连续的。

分页机制首先将物理内存分割成大小相等的页框，然后再将请求放入物理内存的数据（比如代码段）也分割成同样大小的页，最后将所有页都映射到页框上。也就是说页对应的是逻辑地址，页框对应的是物理内存。每个进程都维护一个页表。我的一个疑问是对于代码段和数据段中的逻辑地址，如何确定自己的页号呢？这其实是很简单的，因为我们将整个逻辑地址都进行了页的划分，那么直接将对应的逻辑地址除4K就可以了，而余数刚好就是我们的页内偏移。从当前的角度考虑似乎并不需要每个进程都维护一个页表，但是如果考虑到内存的换入与换出，每个进程对应一个页表是应该存在的。

倘若每个进程都维护一个页表，每个页表有$2^{32}/2^{12}$即1M项，每一项通常占4个字节，那么一个进程的页表占4MB，100个进程就需要占用400MB，这对内存来说是非常大的浪费。

### 改进

一个很直观的改进就是对于没有页框对应的页将其页表项删除，但是随之而来的问题是不连续的逻辑页号，导致查找的时间代价增大。倘若现在页表中仅有$2^{10}$项，也需要10此额外的页表访问。这意味着每进行一次地址转换，都要伴随着进行额外10次内存访问。

### 多级页表

将一维的页号变成二维的页目录加页号（该页目录中的第几个），我们告诉进程每个页目录中都存放哪些内容，但是并不维护所有的页目录，仅仅维护那些页目录上与页框存在映射的。

![屏幕截图 2022-07-11 162716](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-11 162716.png)

基于页目录指针和页目录号找到对应的页目录项，存有当前页目录的基址，基于此以及页号就能找到对应的页，基于页就能对应到页框。每一个页目录项对应一个页表，一个页表中有1024个页表项，也就是1024个页，一个页4k，算下来一个页目录项对应4M的内存，在虚拟内存中的理解就是每4M内容都有相同的页目录项，每一个页目录项的后22位都是由0到1...1(22个1)。

### TLB（地址转换后援缓冲器）

![屏幕截图 2022-07-11 163158](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-11 163158.png)

## 段页式内存管理与虚拟内存

段页机制结合后进程如何使用内存？这需要回答两个更为具体的问题：程序如何放到内存中？放到内存中的指令如何正确执行？

当磁盘上的一个程序要放入内存时，会依次完成如下工作。

-  在虚拟内存中分割除一些分区，将程序的各个段“放入”，分区分割算法可以使用前面论述过的适配算法。
- 建立段表来记录这个映射关系，对于linux0.11来说就是在LDT表中完善段描述符。
- 将虚拟内存分割成页，选择物理内存中的空闲页框，将虚拟内存中的“页内容”放到物理页框中。
- 建立页表来记录虚拟内存页和物理内存页框之间的映射关系。

放到内存中的指令如何正确执行：

以call 40为例，执行此指令时要先进行地址转换：逻辑地址是CS:40，基于此可算出在虚拟内存中的位置，假设为1040，1040对应的虚拟页号为1040/100 = 10...40，虚拟页号是10，页内偏移为40。查找页表可以得到物理页框号5，最终物理地址是540，取出的指令刚好是mov 1,[300]。

## linux0.11的内存管理

从进程创建的fork()开始，不难想象，进程创建中关于内存的使用就是将这个程序载入内存中，所以此处代码实现要完成的核心工作是四件事：在虚拟内存中分段，建立段表，将虚拟内存页映射到物理内存页框，建立页表。

```c
if (copy_mem(nr,p)) {//父进程向子进程代码段和数据段进行拷贝
		task[nr] = NULL;//如果失败了
		free_page((long) p);//就释放当前页
		return -EAGAIN;
}
```

这里的copy_mem就是要为进程建立内存空间。

```c
int copy_mem(int nr,struct task_struct * p)
{
	unsigned long old_data_base,new_data_base,data_limit;
	unsigned long old_code_base,new_code_base,code_limit;

	code_limit=get_limit(0x0f);
	data_limit=get_limit(0x17);
	old_code_base = get_base(current->ldt[1]);
	old_data_base = get_base(current->ldt[2]);
	if (old_data_base != old_code_base)
		panic("We don't support separate I&D");
	if (data_limit < code_limit)
		panic("Bad data_limit");
	new_data_base = new_code_base = nr * 0x4000000;
	p->start_code = new_code_base;
	set_base(p->ldt[1],new_code_base);
	set_base(p->ldt[2],new_data_base);
	if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
		free_page_tables(new_data_base,data_limit);
		return -ENOMEM;
	}
	return 0;
}
```

其中，`get_limit`用于获取一个段选择符的段限长，`get_base`用于获取一个段选择符的基址，`set_base`用来在段选择符中设定一个段的基址。我们以`get_base`（定义在sched.h中）为例，详细分析一下：

```c
#define _get_base(addr) ({\
unsigned long __base; \
__asm__("movb %3,%%dh\n\t" \
	"movb %2,%%dl\n\t" \
	"shll $16,%%edx\n\t" \
	"movw %1,%%dx" \
	:"=d" (__base) \
	:"m" (*((addr)+2)), \
	 "m" (*((addr)+4)), \
	 "m" (*((addr)+7))); \
__base;})

#define get_base(ldt) _get_base( ((char *)&(ldt)) )
```

我们向get_base中传入一个段选择符（一个8字节的结构体），&取出对应段选择符的地址，并转换为指向字符的指针，作为参数传入`_get_base`中，

`"m" (*((addr)+2))`，也就是将段选择符第二个字节的内容取出来放入内存中，最后看到会放入dx中，后面两句类似理解，整个操作下来就是将段选择符中的基址放入edx中并赋给_base并返回。

接下来回到copy_mem的代码，我们申请了一个新的基址作为新创建的进程的代码段和数据段的基址，`new_data_base = new_code_base = nr * 0x4000000;`，在linux0.11中一个进程占64MB，所以申请的是这样的一个基址（对于linux0.11来说进程对于虚拟空间的划分是十分简单的，没有一些特殊的算法）。然后就是在段表中建立段的映射关系`set_base(p->ldt[1],new_code_base);`。

段处理完后，接下来要做的就是实现分页，建立页表。对于物理内存来说，分页操作在操作系统初始化时就已经完成。接下来要做的就是将虚拟内存分割成页，并且和物理页框建立映射关系。对应在copy_mem中的代码是：`copy_page_tables(old_data_base,new_data_base,data_limit)`。在linux0.11中进程的创建就是进程的拷贝，子进程页表的建立当然也是拷贝的过程，但是有一点需要注意的是子进程与父进程不同段也就是页号不同，这并不简简单单就是复制父进程的页表。虚拟地址中的高10位即页目录号与页目录基址确定页目录项在页目录表中的位置，具体的页目录项的内容就是指出对应的页表的基址，而页表的基址加上虚拟地址中的中10位即页号就确定了页表中的第几项，而页表项中的内容就是确定当前页映射的物理页框。**整个流程走下来，把整个进程拼在一起，是页表决定了页到页框的映射。对于父子进程来说，我们希望如果编译之后使用相同的逻辑地址那么映射到相同的物理地址。也就是说子进程的页表应该完全复制父进程的页表。**

```c
// 定义在mm目录下的memory.c文件中
int copy_page_tables(unsigned long from,unsigned long to,long size)
{
	unsigned long * from_page_table;
	unsigned long * to_page_table;
	unsigned long this_page;
	unsigned long * from_dir, * to_dir;
	unsigned long nr;

	if ((from&0x3fffff) || (to&0x3fffff))
		panic("copy_page_tables called with wrong alignment");
	from_dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
	to_dir = (unsigned long *) ((to>>20) & 0xffc);
	size = ((unsigned) (size+0x3fffff)) >> 22;
	for( ; size-->0 ; from_dir++,to_dir++) {
		if (1 & *to_dir)
			panic("copy_page_tables: already exist");
		if (!(1 & *from_dir))
			continue;
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
		if (!(to_page_table = (unsigned long *) get_free_page()))
			return -1;	/* Out of memory, see freeing */
		*to_dir = ((unsigned long) to_page_table) | 7;
		nr = (from==0)?0xA0:1024;
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
			this_page = *from_page_table;
			if (!(1 & this_page))
				continue;
			this_page &= ~2;
			*to_page_table = this_page;
			if (this_page > LOW_MEM) {
				*from_page_table = this_page;
				this_page -= LOW_MEM;
				this_page >>= 12;
				mem_map[this_page]++;
			}
		}
	}
	invalidate();
	return 0;
}
```

其中比较关键的代码如下：

```c
int copy_page_tables(unsigned long from,unsigned long to,long size)
{
    from_dir = (unsigned long *) ((from>>20) & 0xffc); 
	to_dir = (unsigned long *) ((to>>20) & 0xffc);
    for( ; size-->0 ; from_dir++,to_dir++) {
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
		if (!(to_page_table = (unsigned long *) get_free_page()))
			return -1;	
		*to_dir = ((unsigned long) to_page_table) | 7;
		nr = (from==0)?0xA0:1024;
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
			this_page = *from_page_table;
			if (!(1 & this_page))
				continue;
			this_page &= ~2;
			*to_page_table = this_page;
			if (this_page > LOW_MEM) {
				*from_page_table = this_page;
				this_page -= LOW_MEM;
				this_page >>= 12;
				mem_map[this_page]++;
			}
		}
	}
	invalidate();
	return 0;
}
```

一个进程在内存中占64MB，共16个页目录。虚拟地址自身携带信息，当我从逻辑地址映射到虚拟地址后，就能根据虚拟地址的高10位确定当前地址的页目录号，然后在页目录表中找到页目录项，从而找到页目录项对应的页表的基址，所以我们需要做的是建立当前进程的页目录项与对应页表之间的关系。

`from_dir = (unsigned long *) ((from>>20) & 0xffc); `获取父进程段基址的页目录项在页目录表中的位置，具体理解为`from>>22`得到页目录号，而在页目录表中一个页目录项占4个字节，故`(from>>22) x 4`代表对应页目录项在页目录表中的位置，而我们知道页目录表被初始化放在内存的0地址处，也就是说页目录表的基址为0，那么页目录项在页目录表中的位置就是页目录项在内存中的位置，故转换为   `unsigned long *`。

外层循环`for( ; size-->0 ; from_dir++,to_dir++)`就是遍历所有页目录项。

`from_page_table = (unsigned long *) (0xfffff000 & *from_dir);`取父进程当前页目录项对应的页表的基址。对于子进程来说，取空白页作为子进程当前页目录项对应的页表，通过`*to_dir = ((unsigned long) to_page_table) | 7;`建立联系，也就是修改页目录项中的内容。

内层循环`for ( ; nr-- > 0 ; from_page_table++,to_page_table++)`复制页表。一个页表项也占4个字节，即`(unsigned long *)`，故`++`能够完成页表的复制。` *from_page_table`取出当前页表项的内容也即页对应的页框号。注意通过`this_page &= 2`将页表的倒数第2位置为0，用来表示这一页只读。

![屏幕截图 2022-07-13 154554](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-13 154554.png)

![屏幕截图 2022-07-13 154609](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-13 154609.png)

**一个非常重要的理解是从逻辑地址不断映射最终映射到物理地址的整个过程中，页是被我们看作最小单元的，页内偏移在找到真正的页框之后才会使用。**

## 内存的换入与换出

使用换入与换出，用一个小的物理内存来制造出一个大而规整的虚拟内存用户视图。

### 页面的换入

当虚拟页号没办法映射到物理内存时，需要进行换入（缺页中断）。

具体实现：

```c
void trap_init(void) {
    // 设置14号缺页中断
    set_trap_gate(14,&page_fault);
}
```

```c
_page_fault:
	xchgl %eax,(%esp)
	pushl %ecx
	pushl %edx
	push %ds
	push %es
	push %fs
	movl $0x10,%edx
	mov %dx,%ds
	mov %dx,%es
	mov %dx,%fs
	movl %cr2,%edx
	pushl %edx
	pushl %eax
	testl $1,%eax
	jne 1f
	call _do_no_page
	jmp 2f
1:	call _do_wp_page
2:	addl $8,%esp
	pop %fs
	pop %es
	pop %ds
	popl %edx
	popl %ecx
	popl %eax
	iret
```

首先取出导致页面错误的类型，判断页面是没有映射还是越权读写。这个错误类型会被压到内核栈中，命令`xchgl %eax,(%esp)`会将这个错误类型取出来赋给eax寄存器，cr2寄存器中存放出现内存读写的虚拟地址，如果是缺页，cr2中存放的就是发生缺页时的虚拟地址，进而知道到底缺了哪个页。

`push %edx push %eax`将参数压入，调用函数`do_no_page`（缺页）或者`do_wp_page`（写保护即写一个只读页）。核心代码：

```c
void do_no_page(unsigned long error_code,unsigned long address)
{
	int nr[4];
	unsigned long tmp;
	unsigned long page;
	int block,i;

	address &= 0xfffff000;
	if (!(page = get_free_page()))
		oom();
	bread_page(page,current->executable->i_dev,nr);
	if (put_page(page,address))
		return;
}
```

`address &= 0xfffff000`用来算出虚拟号，`page = get_free_page()`用来获得空闲物理内存页框，`bread_page(page,current->executable->i_dev,nr)`用来启动磁盘读写来读取虚拟页面的内容，put_page(page,address)用来填写页表项，完成映射。

### 页面的换出

换出要解决的基本问题就是选择哪个页面进行淘汰，在这个过程中我们的评价指标是缺页次数。

#### FIFO

#### OPT

#### LRU（基于时间戳）

#### LRU（基于页面栈）

#### clock算法



