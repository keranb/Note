# 设备驱动

> 从文件视图到out指令

## 设备驱动的基本原理

CPU对外设的使用主要由如下两条主线构成：

第一条主线从CPU开始，CPU发送命令给外设，最终表现为CPU执行指令`out ax,端口号`;

第二条主线是从外设开始，外设在完成工作后或出现状态变化时通过中断通知CPU，CPU通过中断处理程序完成后续工作。

![屏幕截图 2022-07-14 150426](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-14 150426.png)

对于一个标准设备来说，主要由两部分构成。第一部分是向系统其他部分展现的硬件接口。第二部分是它的内部结构。

![屏幕截图 2022-07-14 150940](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-14 150940.png)

一个（简化的）设备接口包含 3 个寄存器：

一个状态（status）寄存器，可以读取并查看设备的当前状态；

一个命令（command）寄存器，用于通知设备执行某个具体任务；

一个数据（data）寄存器，将数据传给设备或从设备接收数据。

通过读写这些寄存器，操作系统可以控制设备的行为。

### 操作系统与设备交互的方法

第一中方法是使用明确的IO指令，这些指令规定了操作系统将数据发送到特定设备寄存器的方法。例如在 x86 上，in 和 out 指令可以用来与设备进行交互。当需要发送数据给设备时，调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口。执行这个指令就可以实现期望的行为。

第二种方法是内存映射 I/O（memory- mapped I/O）。通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。

### 纳入操作系统：设备驱动程序

每个设备都有非常具体的接口，如何将它们纳入操作系统，而我们希望操作系统尽可能通用。例如文件系统，我们希望开发一个文件系统可以工作在SCSI 硬盘、IDE 硬盘、USB 钥匙串设备等设备之上，并且希望这个文件系统不那么清楚对这些不同设备发出读写请求的全部细节。

在最底层，**操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序**（device driver），所有设备交互的细节都封装在其中。

我们来看看 Linux 文件系统栈，理解抽象技术如何应用于操作系统的设计和实现。

文件系统（当然也包括在其之上的应用程序）完全不清楚它使用的是什么类型的磁盘。它**只需要简单地向通用块设备层发送读写请求即可**，块设备层会将这些请求路由给对应的设备驱动，然后设备驱动来完成真正的底层操作。

![屏幕截图 2022-07-14 154248](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-14 154248.png)

### 简单的 IDE 磁盘驱动程序 

IDE 硬盘暴露给操作系统的接口比较简单，包含 4 种类型的寄存器，即控制、命令块、状态和错误。在 x86 上，利用 I/O 指令 in 和 out 向特定的 I/O 地址（如下面的 0x3F6）读取或写入时，可以访问这些寄存器。

```c
Control Register: 
 Address 0x3F6 = 0x80 (0000 1RE0): R=reset, E=0 means "enable interrupt" 
Command Block Registers: 
 Address 0x1F0 = Data Port 
 Address 0x1F1 = Error 
 Address 0x1F2 = Sector Count 
 Address 0x1F3 = LBA low byte 
 Address 0x1F4 = LBA mid byte 
 Address 0x1F5 = LBA hi byte 
 Address 0x1F6 = 1B1D TOP4LBA: B=LBA, D=drive 
 Address 0x1F7 = Command/status 
Status Register (Address 0x1F7): 
 7 6 5 4 3 2 1 0 
 BUSY READY FAULT SEEK DRQ CORR IDDEX ERROR 
Error Register (Address 0x1F1): (check when Status ERROR==1) 
 7 6 5 4 3 2 1 0 
 BBK UNC MC IDNF MCR ABRT T0NF AMNF 
 BBK = Bad Block 
 UNC = Uncorrectable data error 
 MC = Media Changed 
 IDNF = ID mark Not Found 
 MCR = Media Change Requested 
 ABRT = Command aborted 
 T0NF = Track 0 Not Found 
 AMNF = Address Mark Not Found 
```

下面是与设备交互的简单协议，假设它已经初始化了:

- 等待驱动就绪。读取状态寄存器（0x1F7）直到驱动 READY 而非忙碌。
- 向命令寄存器写入参数。写入扇区数，待访问扇区对应的逻辑块地址（LBA），并将驱动编号（master=0x00，slave=0x10，因为 IDE 允许接入两个硬盘）写入命3令寄存器（0x1F2-0x1F6）。
- 开启 I/O。发送读写命令到命令寄存器。向命令寄存器（0x1F7）中写入 READ-WRITE 命令。
-  数据传送（针对写请求）：等待直到驱动状态为 READY 和 DRQ（驱动请求数据），向数据端口写入数据。
-  中断处理。在最简单的情况下，每个扇区的数据传送结束后都会触发一次中断处理程序。较复杂的方式支持批处理，全部数据传送结束后才会触发一次中断处理。错误处理。在每次操作之后读取状态寄存器。如果 ERROR 位被置位，可以读取错误寄存器来获取详细信息

```c
static int ide_wait_ready() { 
 while (((int r = inb(0x1f7)) & IDE_BSY) || !(r & IDE_DRDY)) 
 ; // loop until drive isn't busy 
} 
static void ide_start_request(struct buf *b) { 
 ide_wait_ready(); 
 outb(0x3f6, 0); // generate interrupt 
 outb(0x1f2, 1); // how many sectors? 
 outb(0x1f3, b->sector & 0xff); // LBA goes here ... 
 outb(0x1f4, (b->sector >> 8) & 0xff); // ... and here 
 outb(0x1f5, (b->sector >> 16) & 0xff); // ... and here! 
 outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f)); 
 if(b->flags & B_DIRTY){ 
 outb(0x1f7, IDE_CMD_WRITE); // this is a WRITE 
 outsl(0x1f0, b->data, 512/4); // transfer data too! 
 } else { 
 outb(0x1f7, IDE_CMD_READ); // this is a READ (no data) 
 } 
} 
void ide_rw(struct buf *b) { 
 acquire(&ide_lock); 
 for (struct buf **pp = &ide_queue; *pp; pp=&(*pp)->qnext) 
 ; // walk queue 
 *pp = b; // add request to end 
 if (ide_queue == b) // if q is empty 
 ide_start_request(b); // send req to disk 
 while ((b->flags & (B_VALID|B_DIRTY)) != B_VALID) 
 sleep(b, &ide_lock); // wait for completion 
 release(&ide_lock); 
} 
void ide_intr() { 
 struct buf *b; 
 acquire(&ide_lock); 
 if (!(b->flags & B_DIRTY) && ide_wait_ready() >= 0) 
 insl(0x1f0, b->data, 512/4); // if READ: get data 
36.10 小结 311 
 b->flags |= B_VALID; 
 b->flags &= ˜B_DIRTY; 
 wakeup(b); // wake waiting process 
 if ((ide_queue = b->qnext) != 0) // start next request 
 ide_start_request(ide_queue); // (if one exists) 
 release(&ide_lock); 
}
```

第一个是 ide_rw()，它会将一个请求加入队列（如果前面还有请求未处理完成），或者直接将请求发送到磁盘（通过 ide_start_request()）。不论哪种情况，调用进程进入睡眠状态，等待请求处理完成。第二个是 ide_start_request()，它会将请求发送到磁盘（在写请求时，可能是发送数据）。此时 x86 的 in 或 out 指令会被调用，以读取或写入设备寄存器。在发起请求之前，开始请求函数会使用第三个函数 ide_wait_ready()，来确保驱动处于就绪状态。最后，当发生中断时，ide_intr()会被调用。它会从设备中读取数据（如果是读请求），并且在结束后唤醒等待的进程，如果此时在队列中还有别的未处理的请求，则调用ide_start_request()接着处理下一个 I/O 请求。

### 文件视图

不管是什么样的外设，操作兄通过都将其统一抽象成一个文件，程序员通过文件接口open,read,write来使用这些外设。采用这样的统一结构之后，在上层用户眼里，对外设的操作和对文件的操作是完全一样的，上层用户可以完全忽略诸如外设端口号，设备指令格式等诸多细节。**操作系统负责将“设备文件”的读写展开成对设备的具体操作，形成一系列out语句**。

![屏幕截图 2022-07-14 155114](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-14 155114.png)

## 显示器的驱动

故事从printf开始，printf是一个库函数，该库函数会将`%d,%c`等内容统一处理为字符串，然后以该字符串所在的内存地址buf和字符串长度count为参数调用系统调用write(1,buf,count)。write的内核实现是sys_write。所以printf的下一步就是sys_write。sys_write首先要做的即使找到所写文件的属性，即到底是普通文件还是设备文件。如果是设备文件，sys_write要根据设备文件中存放的设备属性信息转到相应的操作命令。

```c
int sys_write(unsigned int fd,char *buf,int count){
    struct file* file;
    file = current->filp[fd];
    inode = file->f_inode;
    ...
}
```

current->filp存放了当前进程打开的文件，根据文件句柄fd可以找到当前文件的filepointer。而file->f_inode中存放的什么内容？指向哪个文件？这需要从它的赋值开始讲起。fd=1的文件对应标准输出，因为每个进程都可能用到标准输出，所以每个进程都会打开这个文件。既然所有进程都要打开这个设备文件，操作系统初始化时的1号进程会首次打开这个设备文件，然后其它进程继承这个文件句柄。

```c
void init(void) {
    open("/dev/tty0",O_RDWR,0);
    dup(0);
    dup(0);
    execve("/bin/sh",argv,envp);
}
```

系统调用open的核心工作就是找到文件对应的FCB（在磁盘上），将其读入到内存里，并和进程的PCB进行关联。

![屏幕截图 2022-07-14 164116](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-07-14 164116.png)

从上图中我们可以看到，file是PCBfilp数组中的某个元素，file指向的f_inode就是当前文件对应的FCB（file_table中）。

现在显示器对应的设备文件已经找到了，就是文件"/dev/tty0"，其属性信息存放到了sys_write函数中的inode变量中了。

## 文件视图的大量分支

接下来就是不断往下层深入。

```c
// sys_write 代码片段（根据文件属性进行分支）
int sys_srite(unsigned int fd,char *buf,int cnt){
    if(S_ISCHR(inode->i_mode))
        return rw_char(WRITE,inode->i_zone[0],buf,cnt);
}
```

首先根据inode中的信息判断该文件对应的设备是否是一个字符设备，显示器就是一个字符设备，现在sys_write就要分知道函数`rw_char(WRITE,inode->i_zone[0],buf,cnt);`去执行，其中inode->i_zone[0]中存放的就是该设备的主设备号和次设备号。

```c
int rw_char(int rw,int dev,char *buf,int cnt){
    crw_ptr call_addr = crw_table[MAJOR(dev)];
    call_addr(rw,dev,buf,cnt);
}
/* 
crw_table是一个函数指针数组
static crw_ptr crw_table[] = {... rw_ttyx ...};
*/
static int rw_ttyx(int rw,unsigned minor,char *buf,int count){
    retrun ((rw == READ)? tty_read(minor,buf): tty_write(minor,buf));
}
```

rw_char中以主设备号`(MAJOR(dev))`为索引从一个函数表crw_table中查找和中断设备对应的读写函数rw_ttyx，然后调用这个函数。

函数rw_ttyx根据是设备读操作还是设备写操作继续分支。显示器和键盘合在一起构成了终端设备tty，显示器只写，键盘只读。

tty_write首先获得一个结构体tty_struct，主要目的是在这个结构体中找到队列tty->write_q。实际上，站在用户的角度，输出到显示器就是输出到这个队列中。最终要等到合适的时候，由操作系统统一将队列中的内容输出到显示器上。

```c
int tty_write(unsigned channel,char *buf,int nr){
    struct tty_struct *tty;
    tty = channel + tty_table;
    sleep_if_full(&tty->write_q);
    char c,*b = buf;
    while(nr > 0 && !FULL(tty->write_q)){
        c = get_fs_byte(b);
        if (c == 'r'){PUTCH(13,tty->write_q);continue;}
        if(O_LCUC(tty)) c = toupper(c);
        PUTCH(c,tty->write_q);
        b++;
        nr--;
    }
    tty->write(tty);
}
```

在写显示队列之前，需要判断显示队列是否已满，这是典型的生产者-消费者问题。tty_write是生产者，用`sleep_if_full(&tty->write_q);`（在函数中肯定也会进行临界区的实现）进行P操作，如果发现队列已满，就睡眠等待。如果队列未满，则进入循环，每次循环都会先从用户内存中取出一个字符（使用`get_fs_byte(b)`从用户内存取出字符，因为当前处于内核态，sys_write作为一个系统调用，**这之后就进入内核态了**），然后根据取出的字符进行一些操作，如果是换行，则将13放入tty->write_q中。循环结束将b++（下一个字符），nr--。

本次printf要输出的内容输出完毕或者队列已满时，就调用tty->write(tty)，即用tty结构体中write函数指针来进行真实的显示器输出。（现在可以感觉到的是tty是关于输出信息的结构体）。从对tty结构体的初始化可以看出，tty->write调用的函数是con_write。

```c
void con_write(stuct tty_struct *tty){
    GETCH(tty->write_q,c);
    if (c > 31 && c < 127){
        __asm__("movb attr,%%ah"
               "movw %%ax,%1"::"a"(c),"m"(*(short*)pos):"ax");
        pos += 2;
    }
}
```

con_write是一段嵌入式汇编代码，具体完成的工作是：

```c
mov c,al
mov attr,ah
mov ax,[pos]
```

即将要输出的字符放在寄存器ax的低8位，将显示属性attr放到ax的高8位，然后将ax输出到地址pos处。con_write中每输出一个ax就让pos加2，这是必然的，因为ax就是两个字节。所以理解pos的关键在一pos的初值，在初始化函数con_init中，调用函数gotoxy将pos的值初始化为origin + [0x90001]*video_size_row + ([0x90000]<<1)。在系统启动时的setup.s时利用的BIOS终端将当前光标的行，列位置取出来放到了0x90000和0x90001处。而origin是显存在内存中的初始位置。因此初始化以后pos就是开机以后当前光标所在的显存位置。故mov ax,[pos]就是将printf要显示的字符放在显存的当前光标位置处。至于为什么是mov而不是out，说明当前机器的外设和内存统一编址。

## 键盘驱动

按下键盘会产生0x21号中断，所有键盘的故事从设置0x21号中断的中断处理函数开始。

```c
void con_init(void) {
    set_trap_gate(0x21,&keyboard_interrupt);
}
keyboard_interrupt:
	inb $0x60,%al
    call keytable(,%eax,4)
    ...
    push $0
    call do_tty_interrupt
```

键盘中断的第一句`inb $0x60,%al`就是从键盘的0x60号端口上获得按键扫描，然后根据这个扫描码调用不同的处理函数来处理各个按键。`keytable(,%eax,4)`代表keytable+%eax*4，这是因为在keytable中每一项都是long类型也就是4个字节。

```c
key_table:
	.long none,do_self,do_self,do_self	/* 00-03 s0 esc 1 2 */
	.long do_self,do_self,do_self,do_self	/* 04-07 3 4 5 6 */
	.long do_self,do_self,do_self,do_self	/* 08-0B 7 8 9 0 */
	.long do_self,do_self,do_self,do_self	/* 0C-0F + ' bs tab */
	.long do_self,do_self,do_self,do_self	/* 10-13 q w e r */
```

可以看到绝大多数按键都是交由do_self函数处理。

```
do_self:
	lea alt_map,%ebx
	testb $0x20,mode		/* alt-gr */
	jne 1f
	lea shift_map,%ebx
	testb $0x03,mode
	jne 1f
	lea key_map,%ebx		// 重要
1:	movb (%ebx,%eax),%al	// 重要
	orb %al,%al
	je none
	testb $0x4c,mode		/* ctrl or caps */
	je 2f
	cmpb $'a,%al
	jb 2f
	cmpb $'},%al
	ja 2f
	subb $32,%al
2:	testb $0x0c,mode		/* ctrl */
	je 3f
	cmpb $64,%al
	jb 3f
	cmpb $64+32,%al
	jae 3f
	subb $64,%al
3:	testb $0x10,mode		/* left alt */
	je 4f
	orb $0x80,%al
4:	andl $0xff,%eax
	xorl %ebx,%ebx
	call put_queue
none:	ret
```

对于do_self函数来说，首先做的是找到当前按键的ASCII码，`lea key_map,%ebx`指令取出key_map的偏移地址（也就是基址）赋给%ebx。然后`mov (%ebx,%eax),%al`让%ebx加上%eax然后赋给%al，在key_map中一个ASCII码占一个字节，%eax中存放的就是对应的扫描码。然后找tty结构体中的read_q队列，找到之后就将ASCII码放入read_q队列中。

接下来做的就是反馈给上层进程，也就是说进程需要查看键入的内容，这就相当于进程printf之后在显示器上显示。这部分操作是由`do_tty_interrupt`完成的。

```c
void do_tty_interrupt(int tty)
{
	copy_to_cooked(tty_table+tty);
}


void copy_to_cooked(struct tty_struct *tty){
    GETCH(tty->read_q,c);
    PUTCH(c,tty->secondary);
    ...
    wake_up(&tty->secondary.proc_list);
}
```

copy_to_cooked具体的工作就是从read_q中取出字符（GETCH(tty->read_q,c);），将该字符放在tty->secondary队列中（PUTCH(c,tty->secondary);），同时唤醒等待这个队列上的进程。

整体流程如下：进程通过文件读取接口"read"发起一个设备读操作，接下来该进程会在文件视图中阻塞（睡眠，因为当前read_q中没有内容可读）。直到发生了键盘中断键入了内容，这时通过`do_tty_interrupt`会将内容放入tty->secondary队列，并将对应进程唤醒，醒来的进程从缓冲区取出内容进行处理。**文件操作是由用户发起的，即用户启动了一个进程调用"read"来发起设备读操作；设备中断是由设备动作发起的，由操作系统的中断处理函数负责处理，两条线之间通过上述同步机制连接在一起。**

```c
// tty_read核心代码

int tty_read(unsigned channel,char *buf,int nr){
    sleep_if_empty(&tty->secondary);
    do{
        GETCH(tty->secondary);
        tty->secondary.data--;
        put_fs_byte(c,b++);
    }while (nr>0 && !EMPTY(tty->secondary));
}
```

