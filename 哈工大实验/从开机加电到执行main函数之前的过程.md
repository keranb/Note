# 从开机加电到执行main函数之前的过程

## BIOS

### BIOS的启动原理

CPU的硬件都设计为加电即进入16位实模式状态运行。同时，还有一点非常关键的是，将CPU硬件逻辑设计为加电瞬间强行将CS的值设置为0xF000，IP的值设置为0xFFF0，这样CS:IP就指向0xFFF0这个地址位置。

### BIOS在内存中加载中断向量表和中断服务程序

BIOS从0xFFF0处开始执行程序，其中一个关键的动作就是加载中断向量表和中断服务程序。

![屏幕截图 2022-08-19 082706](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-08-19 082706.png)

## 加载操作系统内核程序并为保护模式做准备

> 这里我们只是给出大致框架，详细的见对应笔记

从现在开始，就要执行真正的boot操作了，按照我们使用计算机的经验，如果在开机的时候马上按Del键，屏幕上会显示一个BIOS画面，可以在里面设置启动设备。现在我们基本上都是将硬盘设置为启动盘。Linux0.11使用的启动设备是软驱以及其中的软盘。

经过一系列BIOS代码之后，计算机硬件体系结构的设计与BIOS联手操作，会让CPU接收到一个int 0x19中断。CPU收到这个中断后，会立即在中断向量表中找到int 0x19中断向量，跳转到int 0x19对应的中断服务程序的入口地址，即“启动加载服务程序”的入口地址。

### bootsect.s

由此就真正开始加载内核程序，首先加载的是启动设备的第一个扇区（磁盘引导扇区，512字节，bootsect.s）。将其读入内存绝对地址0x7C00处，并跳转到这个地方开始执行。bootsect代码执行时，它会将子集移动到内存绝对地址0x90000开始处并继续执行。该程序的首先把磁盘第二个分区开始的四个分区setup模块加载到内存中紧接着bootsect后面位置处（0x90200），然后利用BIOS中断0x13取磁盘参数表中当前启动引导盘的参数，接着在屏幕上显示“Loading system..."字符串（这也需要利用BIOS中断）。再把磁盘上setup模块后面的system模块加载到内存0x10000开始的地方。随后确定根文件系统的设备号，若没有指定，则根据所保存的引导盘的每磁道扇区数判断处盘的类型和种类并保存其设备号于root_dev，最后长跳转到setup程序的开始处。

### setup.s

主要的作用是利用ROM BIOS中断读取机器系统数据，并将这些数据保存到0x90000开始的位置（覆盖掉了bootsect程序所在的地方）。然后关中断准备进入保护模式，并将sysetm模块从0x10000-0x8ffff整块向下移动到内存绝对地址0x00000处（覆盖掉了BIOS创建的中断向量表）。接下来加载中断描述表寄存器(idtr)和全局描述表寄存器(gdtr)，开启A20地址线（打开A20意味着CPU可以进行32位寻址），重现设置两个中断控制芯片8259A，将硬件中断号重新设置为0x20-0x2f。最后设置CPU的控制寄存器CR0，从而进入32位保护模式运行，并跳转到位于system模块最前面部分的head.s程序继续运行。

因为我们需要利用BIOS创建的中断向量表读取系统数据，所以我们在读取完数据之后，才开始移动system模块。

我们加载中断描述表寄存器和全局描述表寄存器是为了让我们能够找到中断描述表和全局描述表，基于此，我们同通过lidt指令加载中断描述寄存器idtr时需要6字节的操作数，前2字节是IDT表的限长，后四字节是IDT表在线性地址空间中的32位基址。在代码中我们可以看到我们的6字节操作数为

```c
idt_48:
	.word 0
    .word 0,0
```

同理，通过lgdt指令加载全局描述寄存器gdtr，这6字节操作数为

```c
gdt_48:
	.word 0x800
    .word 512+gdt,0x9
```

可以看出gdt表的基址为0x9xxxx，就是当前setup代码段中gdt标号所在位置。这里给出了三个描述符项，第一项无用，第二项是内核代码段描述符，第三项是内核数据段描述符。

```c
gdt:
	.word 0,0,0,0
    
    .word 0x07FF // 低字节
    .word 0x0000
    .word 0x9A00
    .word 0x00C0 // 高字节
        
    .word 0x07FF
    .word 0x0000
    .word 0x9200
    .word 0x00C0
```

![屏幕截图 2022-05-29 085321](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-05-29 085321.png)

基于段描述符的构成，我们将内核代码段的段描述符分析一下：

它的31-16(最低16位)为`00000000 00000000 `,39-32(次低8位)为`00000000`,63-56(高8位)为`00000000` 合并起来构成段基址：`00000000 00000000 00000000 00000000`

最后我们是通过长跳转指令jmpi 0,8跳转至system模块开始执行，这里是在进入保护模式之后进行跳转的，基于上述分析，CS为段选择子，`0000 0000 0000 1000`，最低两位代表特权级，倒数第三位代表选择GDT还是LDT，倒数第四位1代表选择GDT中的第二项也就是内核代码段对应的段描述符，段基址为`00000000 00000000 00000000 00000000`，偏移也为0，也就指向了我们的system模块。

![屏幕截图 2022-08-19 095734](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-08-19 095734.png)

### head.s

head汇编程序与前面的格式不同，它采用的是AT&T的汇编语言格式。

**设置数据段寄存器**

```c
movl $0x10,%eax;
movl %ax,%ds;
movl %ax,%es;
movl %ax,%fs;
movl %ax,%gs;
lss _stack_start_%esp
```

将`%ds,%es,%fs,%gs`这些数据段,存器中的段选择子指向内核数据段，也就是GDT表中的第三项，内核数据段与内核代码段基址相同，均为0x000000。

`lss _stack_start_,%esp`用于设置系统堆栈。在kernel/sched.c中，stack_start = {&user_stack[PAGE_SIZE>>2],0x10}，这行代码将栈顶指针指向user_stack数据结构的最末位置，同时将%ss也设置为内核数据段。如下：

![屏幕截图 2022-08-19 170450](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-08-19 170450.png)

**重新设置中断描述表和全局描述表**

我们新设置的GDT表与原来在setup.s程序中设置的GDT表描述符除了在段限长有些区别以外（原为8MB，现为16MB），其他内容完全一样。这里重新设置GDT的主要原因是为了把gdt表放在内存内核代码比较合理的地方。

**检测A20地址线是否真的开启**

A20如果没打开，则计算机处于20位的寻址模式，超过0xFFFFF地址必然”回滚“，一个特例是0x100000会回滚到0x000000，也就是说，地址0x100000处存储的值必然和地址0x000000处存储的值完全相同。通过在内存0x000000位置写入一个数据，然后比较此处和1MB处数据是否一致，就可以检验A20地址线是否已经打开。

**关于main函数的一些压栈**

```c
pushl $0
pushl $0
pushl $0
pushl $L6
pushl $_main
```

head程序将L6标号和main函数入口地址压栈，栈顶为mian函数地址，目的是使head程序执行完后**通过ret指令就可以直接执行main函数**。

![屏幕截图 2022-08-19 172521](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-08-19 172521.png)

**设置管理内存的分页处理机制**

将页目录表放在绝对物理地址0开始处（也是本程序所处的物理内存位置，因此这段程序将被覆盖），紧随后面放置共可寻址16MB的4个页表，并分别设置它们的表项。一个页表和一个页一样大，都是4k，而页表中需要4个字节来指向一个页，所以一个页表中可以指向1k个页，一个页4k，故一个页表可以指向4MB的内存，那么4个页表就是16MB的内存。设置页表的具体做法是将第四个页表（由pg3指向的位置）的最后一个页表项（pg3+4092指向的位置）指向寻址范围的最后一个页面，即0xFFF00开始的4KB字节大小的内存空间。然后开始从高地址向低地址方向填写4个页表，依次指向内存从高地址向低地址方向的各个页面。**这四个页表都是内核专属的页表**。

**head.s程序执行完**

![屏幕截图 2022-08-19 173254](E:\操作系统（哈工大实验，笔记）\imags\屏幕截图 2022-08-19 173254.png)

