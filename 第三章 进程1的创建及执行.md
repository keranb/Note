# 进程1的创建及执行

现在，计算机中已经有了一个名副其实的用户级进程——进程0，下面详细讲解进程0做的第一项工作——创建进程1。

## 进程1的创建

```c
// init/main.c
if (!fork()) {		/* we count on this going ok */
	init();
}
for(;;) pause();
```

### fork

`fork()`是一个系统调用（准确来说是系统调用接口函数），一般系统调用函数都定义在`kernel`目录下。

```c
static inline _syscall0(int,fork)
```

`_syscall0`是一个宏，代表着没有参数的系统调用，这个宏定义在`include/unistd.h`头文件中，其中还定义了系统调用号。其中关键部分我们在系统调用部分已经详细讲解了。当我们把宏展开之后发现关键就是执行了一个`0x80`中断。

```c
#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
	: "=a" (__res) \
	: "0" (__NR_##name)); \
if (__res >= 0) \
	return (type) __res; \
errno = -__res; \
return -1; \
}
```

而`0x80`中断对应的中断函数就是`system_call`，在中断向量表中找到中断函数的入口地址会进行跳转，在这里我们先看看system_call函数在中断向量表中的初始化：

```c
// 在shced_init中完成0x80号中断即系统调用的挂载
set_system_gate(0x80,&system_call);
#define set_system_gate(n,addr) set_gate(&idt[n],15,3,addr)

// set_gate宏汇编代码在system.h中
#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ ("movw %%dx,%%ax\n\t" \
	"movw %0,%%dx\n\t" \
	"movl %%eax,%1\n\t" \
	"movl %%edx,%2" \
	: \
	: "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
	"o" (*((char *) (gate_addr))), \
	"o" (*(4+(char *) (gate_addr))), \
	"d" ((char *) (addr)),"a" (0x00080000))
```

很明显，_set_gate所作的就是在IDT表中填好对应的中断描述符，需要注意的是中断描述符的DPL为3，这样用户程序的CPL作为3也能够访问到，**而对应的中断函数入口地址为CS:0x0008,EIP:&system_call。当我们通过中断进行跳转的时候，特权级发生了改变，由3特权级跳转到0特权级，会发生堆栈的切换，由用户栈切换到内核栈**（这里的内核栈就是当前进程TSS中记录的那个内核栈，中断发生的时候硬件会自动跳转），保存用户态程序的信息，会向内核栈压入一定信息，然后真正进行跳转。

```c
.align 2
_system_call:
	cmpl $nr_system_calls-1,%eax
	ja bad_sys_call
	push %ds
	push %es
	push %fs
	pushl %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters
	pushl %ebx		# to the system call
	movl $0x10,%edx		# set up ds,es to kernel data space
	mov %dx,%ds
	mov %dx,%es
	movl $0x17,%edx		# fs points to local data space
	mov %dx,%fs
	call _sys_call_table(,%eax,4)
	pushl %eax
	movl _current,%eax
	cmpl $0,state(%eax)		# state
	jne reschedule
	cmpl $0,counter(%eax)		# counter
	je reschedule
ret_from_sys_call:
	movl _current,%eax		# task[0] cannot have signals
	cmpl _task,%eax
	je 3f
	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?
	jne 3f
	cmpw $0x17,OLDSS(%esp)		# was stack segment = 0x17 ?
	jne 3f
	movl signal(%eax),%ebx
	movl blocked(%eax),%ecx
	notl %ecx
	andl %ebx,%ecx
	bsfl %ecx,%ecx
	je 3f
	btrl %ecx,%ebx
	movl %ebx,signal(%eax)
	incl %ecx
	pushl %ecx
	call _do_signal
	popl %eax
3:	popl %eax
	popl %ebx
	popl %ecx
	popl %edx
	pop %fs
	pop %es
	pop %ds
	iret
```

关键是`call _sys_call_table(,%eax,4)`根据系统调用号找到对应的系统调用，我们这里对应的系统调用就是`sys_fork()`

现在主要看看对应的系统调用函数的实现。我们知道，系统调用作为一个软中断，中断前的处理和中断后的恢复定义在`kernel/system_call.s`文件中，而具体的中断实现就定义在`kernel`目录下的某个文件中。

```c
.align 2
_sys_fork://fork的系统调用
	call _find_empty_process//调用这个函数
	testl %eax,%eax
	js 1f
	push %gs
	pushl %esi
	pushl %edi
	pushl %ebp
	pushl %eax
	call _copy_process//
	addl $20,%esp
1:	ret
```

这里有一个浅显的认知是：int指令和iret指令的配合使用与call指令和ret指令的配合使用具有相似的思路。会进行一定的入栈和出栈。（`int`指令会使CPU硬件自动将SS，ESP，EFLAGS，CS，EIP这5个寄存器入栈）

首先调用_find_empty_process函数在task中找到第一个空的位置

```c
int find_empty_process(void)
{
	int i;

	repeat:
		if ((++last_pid)<0) last_pid=1;
		for(i=0 ; i<NR_TASKS ; i++)
			if (task[i] && task[i]->pid == last_pid) goto repeat;
	for(i=1 ; i<NR_TASKS ; i++)
		if (!task[i])
			return i;
	return -EAGAIN;//达到64的最大值后，返回错误码
}
```

`repeat:`标号处的代码目前不明所以。还有一个需要注意的点就是函数的返回值放在`%eax`寄存器中，也就是说现在寄存器中就是我们找到的那个空位。

接着执行`testl %eax %eax`指令。testl指令,这个指令说是将两个操作数做与来设置零标志位和负数标识,常用的方法是testl %eax,%eax来检查%eax是正数负数还是0。

`js 1f `  SF符号位为负则进行跳转，也就是说没有找到空位进行跳转。

copy_process函数执行之前内核栈的视图：

![fork](E:\操作系统（哈工大实验，笔记）\imags\fork.png)

内核栈中的CS，EIP保存的就是int0x80后的那一个代码，也就是用户程序即将要执行的那个代码`if (__res >= 0) return (type) __res; \`。通过分析你可以发现，这些内核栈中的寄存器信息都是中断之前用户程序的信息。而copy_process就是基于这些信息创建一个新的用户进程。

```c
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
		long ebx,long ecx,long edx,
		long fs,long es,long ds,
		long eip,long cs,long eflags,long esp,long ss)
{
	struct task_struct *p; 
	int i;
	struct file *f;
	//其实就是malloc分配内存
	p = (struct task_struct *) get_free_page();//在内存分配一个空白页，让指针指向它
	if (!p)
		return -EAGAIN;//如果分配失败就是返回错误
	task[nr] = p;//把这个指针放入进程的链表当中
	*p = *current;//把当前进程赋给p，也就是拷贝一份	/* NOTE! this doesn't copy the supervisor stack */
	//后面全是对这个结构体进行赋值相当于初始化赋值
	p->state = TASK_UNINTERRUPTIBLE;
	p->pid = last_pid;
	p->father = current->pid;
	p->counter = p->priority;
	p->signal = 0;
	p->alarm = 0;
	p->leader = 0;		/* process leadership doesn't inherit */
	p->utime = p->stime = 0;
	p->cutime = p->cstime = 0;
	p->start_time = jiffies;//当前的时间
	p->tss.back_link = 0;
	p->tss.esp0 = PAGE_SIZE + (long) p;
	p->tss.ss0 = 0x10;
	p->tss.eip = eip;
	p->tss.eflags = eflags;
	p->tss.eax = 0;//把寄存器的参数添加进来
	p->tss.ecx = ecx;
	p->tss.edx = edx;
	p->tss.ebx = ebx;
	p->tss.esp = esp;
	p->tss.ebp = ebp;
	p->tss.esi = esi;
	p->tss.edi = edi;
	p->tss.es = es & 0xffff;// 仅后16位有效
	p->tss.cs = cs & 0xffff;
	p->tss.ss = ss & 0xffff;
	p->tss.ds = ds & 0xffff;
	p->tss.fs = fs & 0xffff;
	p->tss.gs = gs & 0xffff;
	p->tss.ldt = _LDT(nr);
	p->tss.trace_bitmap = 0x80000000;
	if (last_task_used_math == current)//如果使用了就设置协处理器
		__asm__("clts ; fnsave %0"::"m" (p->tss.i387));
	if (copy_mem(nr,p)) {//老进程向新进程代码段和数据段进行拷贝
		task[nr] = NULL;//如果失败了
		free_page((long) p);//就释放当前页
		return -EAGAIN;
	}
	for (i=0; i<NR_OPEN;i++)//
		if (f=p->filp[i])//父进程打开过文件
			f->f_count++;//就会打开文件的计数+1，说明会继承这个属性
	if (current->pwd)//跟上面一样
		current->pwd->i_count++;
	if (current->root)
		current->root->i_count++;
	if (current->executable)
		current->executable->i_count++;
	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
	p->state = TASK_RUNNING;//把状态设定为运行状态	/* do this last, just in case */
	return last_pid;//返回新创建进程的id号
}
```

`copy_process`函数作为创建新进程这个业务的主体函数。所作的事情是：

首先，声明一个指向`task_struct`的指针，作为当前新创建进程的task_struct。在内存分配一个空白页，让指针指向它。然后用当前进程的task_struct去初始化新创建进程的task_struct，然后进行具体的修改。

在这个过程中有几个关键点：

- `p->tss.esp0 = PAGE_SIZE + (long) p; p->tss.ss0 = 0x10;`说明新创建的进程的内核栈栈段指向内核数据段0x10，而%esp栈顶指针指向p+PAGE_SIZE，即指向当前分配页的末尾，可以这样理解，一个进程页就是PCB，我们把内核栈放在最高地址，其它的task_struct从最低地址开始扩展。
- `p->tss.eip = eip; p->tss.cs = cs & 0xffff; `，根据前面的分析cs,eip指向`int 0x80`后面那一行代码

后续是对内存管理的相关操作，我们关注在GDT表中对当前进程TSS和LDT段描述符的生成。最后`}`相当于执行`ret`指令回到`sys_fork()`函数执行`addl $20,%esp`。这个操作的目的是让我们的栈指针指向正确的返回地址，使得`ret`指令能够返回到`system_call`中的正确位置。`addl $20,%esp`直接跳过前面入栈的五个寄存器。这里给了我们一定启示，当我们使用`ret`回到调用函数正确位置处要求我们在call指令执行的入栈操作之后没有再进行入栈操作（当然可以入栈再出栈）。

总而言之，现在就回到了`system_call`函数。从`pushl %eax`处开始执行。而`%eax`寄存器中存放的是`sys_fork()`函数的返回值，而`sys_fork()`函数并未对`%eax`进行修改，那么返回的就是`copy_process`函数的返回值，即新创建进程的pid。

> 这里有一点需要补充的是，我们为什么要push %eax,是因为%eax寄存器中的值我们需要使用，而%eax寄存器我们后续也需要使用，于是就先把%eax中的数据压栈。等到需要使用的时候再出栈，放到%eax寄存器中

对于后续代码，我们关注以下几行：

```c
movl _current,%eax
	cmpl $0,state(%eax)		# state
	jne reschedule
	cmpl $0,counter(%eax)		# counter
	je reschedule
ret_from_sys_call:
	movl _current,%eax		# task[0] cannot have signals
	cmpl _task,%eax
	je 3f
```

判断当前进程是否为就绪态，如果不是就绪态，跳转到reschedule。判断当前进程是否还有时间片，如果没有时间片，也跳转到reschedule。然后`cmpl _task,%eax`判断当前进程是否是0号进程，如果是就跳转到标号3处。而我们当前进程确为0号进程。

```c
3:	popl %eax
	popl %ebx
	popl %ecx
	popl %edx
	pop %fs
	pop %es
	pop %ds
	iret
```

执行`popl %eax`，那么当前`%eax`寄存器中存放的就是新创建进程的pid号。最后进行一系列出栈操作之后（因为我们在`system_call()`执行开始时先进行了入栈，为了能使iret指令能够正确的返回，故需要执行一系列出栈）。iret进行中断返回，返回到了系统调用接口函数。

```c
#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
	: "=a" (__res) \
	: "0" (__NR_##name)); \
if (__res >= 0) \
	return (type) __res; \
errno = -__res; \
return -1; \
}

```

这里返回之后，首先会将`%eax`寄存器的值赋给_res变量，也就是新创建进程的pid，我们这里也就是1。进入后面的循环判断，那么我们当前系统调用接口函数的返回值就是1。

ok，接下来回到main主函数。因为fork()函数的返回值就是1，故不会执行init，执行pause()函数。一个重要的理解是fork()返回值非0就说明我们进程创建成功，那么我们就不应该在当前进程继续执行代码，会切换到新的进程，当前来讲就是1号进程，而1号进程保存的状态就是**0号进程执fork()时的状态**。

`pause()`函数也是一个系统调用接口函数

```c
static inline _syscall0(int,pause)
```

对应在`system_call_table`中的系统调用函数为`sys_pause`，就定义在`kernel/sched.c`文件中。中断会基于中断向量表中的中断函数地址进行跳转，在这里就进入了0特权级的内核代码。

```c
int sys_pause(void)
{
	current->state = TASK_INTERRUPTIBLE;
	schedule();
	return 0;
}
```

将当前进程（也就是0号进程）状态置为可中断睡眠状态。然后调用`schedule`进程调用函数，`schedule()`函数肯定会找到1号进程号然后切换到1号进程。具体见对`schedule()`函数的详细描述。要注意，此时各个寄存器中的值都因为进程切换发生了变换，依照1号进程tss段中对寄存器环境的保存。而1号进程tss段中的环境保存还是初始化时的样子。我们再次回到`copy_process()`函数中看看当时保存的是什么样的环境。

```c
p->tss.eip = eip;
p->tss.eflags = eflags;
p->tss.eax = 0;//把寄存器的参数添加进来
```

这里的`%eip`指向fork()函数中的`if (__res >= 0)`，也就是中断指令后的第一条语句。而此时eax=0，所以fork()函数返回值为0，会在1号进程中指向init操作：

```c
// init/main.c
if (!fork()) {		/* we count on this going ok */
	init();
}
for(;;) pause();
```

**总的来讲**

我们首先fork()创建了一个新的进程1号进程，而1号进程的起始状态是从0号进程执行fork()中的int0x80后的那行代码也就是`if (__res >= 0)`。一开始在进程0中执行fork()返回值为1，会执行pause()，pause()会使得进程进行轮转，调度到1号进程，同时需要注意我们在通过0号进程复制1号进程的过程中巧妙地将`p->tss.eax = 0`，这就使得从1号进程开始执行后从fork()返回的是0，会在1号进程中继续执行代码init()。

### 详细讲解copy_process()函数

#### 设置进程1的分页管理

每个进程都要加载属于自己的代码，数据。这些代码，数据的寻址都是用段加偏移的形式，也就是逻辑地址形式表示的。CPU硬件自动将逻辑地址计算为CPU可寻址的线性地址，再根据操作系统对页目录表，页表的设置，自动将线性地址转换为分页的物理地址。

每个进程都有着自己独立的64MB线性地址，通过对线性地址分页并映射到真正的物理页上，这就建立起了分页机制。

在这里沿着**copy_mem()**函数出发，逐渐深入：

```c
// include/linux/sched.h

#define PAGE_ALIGN(n) (((n)+0xfff)&0xfffff000)

#define _set_base(addr,base) \
__asm__("movw %%dx,%0\n\t" \
	"rorl $16,%%edx\n\t" \
	"movb %%dl,%1\n\t" \
	"movb %%dh,%2" \
	::"m" (*((addr)+2)), \
	  "m" (*((addr)+4)), \
	  "m" (*((addr)+7)), \
	  "d" (base) \
	:"dx")

#define _set_limit(addr,limit) \
__asm__("movw %%dx,%0\n\t" \
	"rorl $16,%%edx\n\t" \
	"movb %1,%%dh\n\t" \
	"andb $0xf0,%%dh\n\t" \
	"orb %%dh,%%dl\n\t" \
	"movb %%dl,%1" \
	::"m" (*(addr)), \
	  "m" (*((addr)+6)), \
	  "d" (limit) \
	:"dx")

#define set_base(ldt,base) _set_base( ((char *)&(ldt)) , base )
#define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , (limit-1)>>12 )

#define _get_base(addr) ({\
unsigned long __base; \
__asm__("movb %3,%%dh\n\t" \
	"movb %2,%%dl\n\t" \
	"shll $16,%%edx\n\t" \
	"movw %1,%%dx" \
	:"=d" (__base) \
	:"m" (*((addr)+2)), \
	 "m" (*((addr)+4)), \
	 "m" (*((addr)+7))); \
__base;})

#define get_base(ldt) _get_base( ((char *)&(ldt)) )

#define get_limit(segment) ({ \
unsigned long __limit; \
__asm__("lsll %1,%0\n\tincl %0":"=r" (__limit):"r" (segment)); \
__limit;})

// kernel/fork.c
int copy_mem(int nr,struct task_struct * p)
{
	unsigned long old_data_base,new_data_base,data_limit;
	unsigned long old_code_base,new_code_base,code_limit;

	code_limit=get_limit(0x0f);
	data_limit=get_limit(0x17);
    // 获取父进程代码段和数据段基址
	old_code_base = get_base(current->ldt[1]);
	old_data_base = get_base(current->ldt[2]);
	if (old_data_base != old_code_base)
		panic("We don't support separate I&D");
	if (data_limit < code_limit)
		panic("Bad data_limit");
    // 生成子进程代码段和数据段的基址
	new_data_base = new_code_base = nr * 0x4000000;
	p->start_code = new_code_base;
	set_base(p->ldt[1],new_code_base);
	set_base(p->ldt[2],new_data_base);
	if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
		free_page_tables(new_data_base,data_limit);
		return -ENOMEM;
	}
	return 0;
}
```

copy_mem()所做的主要就是生成子进程的代码段和数据段的基址（线性地址）并在进程的LDT（task_struct）中进行设置。接着进入copy_page_tables()函数。

```c
int copy_page_tables(unsigned long from,unsigned long to,long size)
{
	unsigned long * from_page_table;
	unsigned long * to_page_table;
	unsigned long this_page;
	unsigned long * from_dir, * to_dir;
	unsigned long nr;

	if ((from&0x3fffff) || (to&0x3fffff))
		panic("copy_page_tables called with wrong alignment");
	from_dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
	to_dir = (unsigned long *) ((to>>20) & 0xffc);
	size = ((unsigned) (size+0x3fffff)) >> 22;
	for( ; size-->0 ; from_dir++,to_dir++) {
		if (1 & *to_dir)
			panic("copy_page_tables: already exist");
		if (!(1 & *from_dir))
			continue;
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
		if (!(to_page_table = (unsigned long *) get_free_page()))
			return -1;	/* Out of memory, see freeing */
		*to_dir = ((unsigned long) to_page_table) | 7;
		nr = (from==0)?0xA0:1024;
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
			this_page = *from_page_table;// 当前父进程的真实物理页
			if (!(1 & this_page))
				continue;
			this_page &= ~2;
			*to_page_table = this_page;// 让子进程的页表项也指向这个真实物理页
			if (this_page > LOW_MEM) {// 1MB以内的内核区不参与用户分页管理
				*from_page_table = this_page;
				this_page -= LOW_MEM;
				this_page >>= 12;
				mem_map[this_page]++;// 增加引用计数，参看mem_init()
			}
		}
	}
	invalidate();
	return 0;
}
```

copy_page_tables()接受三个参数，分别是父进程数据段基址（也就是线性地址的起始地址），子进程数据段基址（也就是线性地址的起始地址），数据段限长，基于这三个参数进行页表的拷贝。

![QQ图片20230613125436](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\QQ图片20230613125436.png)

`from_dir = (unsigned long *) ((from>>20) & 0xffc); `获取父进程段基址的页目录项在页目录表中的位置，具体理解为`from>>22`得到页目录号，而在页目录表中一个页目录项占4个字节，故`(from>>22) x 4`代表对应页目录项在页目录表中的位置，而我们知道页目录表被初始化放在内存的0地址处，也就是说页目录表的基址为0，那么页目录项在页目录表中的位置就是页目录项在内存中的位置，故转换为   `unsigned long *`。

外层循环`for( ; size-->0 ; from_dir++,to_dir++)`就是遍历所有页目录项。

`from_page_table = (unsigned long *) (0xfffff000 & *from_dir);`取父进程当前页目录项对应的页表的基址，`0xfffff000 & `将低12位清零。对于子进程来说，取空白页作为子进程当前页目录项对应的页表，通过`*to_dir = ((unsigned long) to_page_table) | 7;`建立联系，也就是修改页目录项中的内容，这就建立了线性地址中的虚拟页与真实的物理页之间的映射关系，通过让当前进程页表中的某一项指向一个真实的物理页。

内层循环`for ( ; nr-- > 0 ; from_page_table++,to_page_table++)`复制页表。一个页表项也占4个字节，即`(unsigned long *)`，故`++`能够完成页表的复制。` *from_page_table`取出当前页表项的内容也即页对应的页框号。注意通过`this_page &= 2`将页表的倒数第2位置为0，用来表示这一页只读。

总的来说，copy_page_tables()完成了父进程整个页目录页表到子进程的复制。由两层循环完成，外层循环针对页目录从第一个页目录项开始，内层循环针对页表从对应页表的第一个页表项开始。让父子进程的页表项指向相同的物理页。

#### 进程1共享进程0的文件

```c
for (i=0; i<NR_OPEN;i++)// 下面将父进程相关文件属性的引用计数加1，表明父子进程共享文件
	if (f=p->filp[i])//父进程打开过文件
		f->f_count++;//就会打开文件的计数+1，说明会继承这个属性
if (current->pwd)//跟上面一样
    current->pwd->i_count++;
if (current->root)
    current->root->i_count++;
if (current->executable)
    current->executable->i_count++;
```

### 详解进程调度函数schedule()

```c
// kernel/sched.c
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		if (*p) {//alarm是用来设置警告，比如jiffies有1000个可能其中一些需要警告那么就用alarm来实现
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
				//~(_BLOCKABLE & (*p)->blocked  
				//&&(*p)->state==TASK_INTERRUPTIBLE
				//用来排除非阻塞信号
				//如果该进程为可中断睡眠状态 则如果该进程有非屏蔽信号出现就将该进程的状态设置为running
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
			(*p)->state==TASK_INTERRUPTIBLE)
				(*p)->state=TASK_RUNNING;
		}

/* this is the scheduler proper: */
	// 以下思路，循环task列表 根据counter大小决定进程切换
	while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;//进程为空就继续循环
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)//找出c最大的task
				c = (*p)->counter, next = i;
		}
		if (c) break;//如果c找到了，就终结循环，说明找到了
		//进行时间片的重新分配
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)//这里很关键，在低版本内核中，是进行优先级时间片轮转分配，这里搞清楚了优先级和时间片的关系
			//counter = counter/2 + priority
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
	//切换到下一个进程 这个功能使用宏定义完成的
	switch_to(next);
}
```

首先是关于信号和警告的一些处理，这部分暂且不管，在进程间通信部分在介绍。

接着就是一个while循环，这个while循环就是我们的优先级时间片轮转调度算法。简单来说就是找寻最大时间片的进程。我们在`schedule`函数开头申请了一个指向`task_struct`指针的指针。原因如下：

![task](E:\操作系统（哈工大实验，笔记）\imags\task.png)我们的`task`进程数组其实是各个`task_struct`的地址。我们在while循环开始的时候让p指针指向NR_TASKS号进程对应的地址（这个进程其实是不存在的，仅仅是方便我们后续操作）。那后续操作也就很简单了，找出counter最大且进程状态为`TASK_RUNNING`的进程。很明显，最后找到的那个进程号放在变量next中，对应的时间片放在变量c中。如果我们找到的c不为0，说明存在着这么一个进程，就退出。如果没找到，说明当前所有进程的时间片都用完了，进行时间片的重新分配。因为并未退出当前while循环，继续寻找最大counter对应的进程。所以，不管怎么样，最后一定会从while循环中退出，然后使用`switch_to`切换到我们找到的这个线程。

**switch_to()**

`switch_to`是定义在`include/linux/sched.h`下的一段宏汇编

```c
#define switch_to(n) {\
struct {long a,b;} __tmp; \
__asm__("cmpl %%ecx,_current\n\t" \
	"je 1f\n\t" \
	"movw %%dx,%1\n\t" \
	"xchgl %%ecx,_current\n\t" \
	"ljmp %0\n\t" \
	"cmpl %%ecx,_last_task_used_math\n\t" \
	"jne 1f\n\t" \
	"clts\n" \
	"1:" \
	::"m" (*&__tmp.a),"m" (*&__tmp.b), \
	"d" (_TSS(n)),"c" ((long) task[n])); \
}
```

有些问题我们先不去深究，大概看下`switch_to`做了什么。首先将`__tmp.a`和`__tmp.b`的值都放入内存中，至于为什么使用`*&__tmp.a`，我们这里不得而知。接着将进程n的TSS段的段选择子放入edx寄存器中，将进程n的`task_struct`的地址放入ecx寄存器中。开始执行汇编代码，首先判断n号进程是否为当前进程，若是则跳转到标号1处，相当于直接终止进程的切换。接着将edx寄存器中的值放入内存，偏移为1处（这里我们无需去管ds寄存器中的段选择子是是什么）。接着交换当前进程与ecx寄存器中的n号进程。

然后是一个非常重要的`ljmp`指令

按AS手册，ljmp指令存在两种形式，即：
  一、直接操作数跳转，此时操作数即为目标逻辑地址（选择子，偏移），即形如：ljmp \$seg_selector, \$offset的方式；
  二、使用内存操作数，这时候，AS手册规定，内存操作数必须用“\*”作前缀，即形如：ljmp \*mem48，其中内存位置mem48处存放目标逻辑地址: 高16bit存放的是seg_selector，低32bit存放的是offset。注意：这条指令里的“\*”只是表示间接跳转的意思，与C语言里的“\*”作用完全不同。

回到源码上，`ljmp %0`用的ljmp的第二种用法，`ljmp *%0`这条语句展开后相当于`ljmp *__tmp.a`，也就是跳转到`&__tmp.a`中包含的48bit逻辑地址处。而按struct \_tmp的定义，这也就意味着`__tmp.a`即为该逻辑地址的offset部分，`__tmp.b`的低16bit为seg_selector(高16bit无用)部分。通过以上说明，可以知道了ljmp将跳转到选择子指定的地方，大致过程是，ljmp判断选择子为TSS类型，于是就告诉硬件要切换任务，硬件首先它要将当前的PC,esp,eax等现场信息保存在当前自己的TSS段描述符中,然后再将目标TSS段描述符中的pc,esp,eax的值拷贝至对应的寄存器中。会实现由0特权级的内核代码到3特权级的用户代码的切换。

## 进程1为安装硬盘文件系统做准备

drive_info 是来自内存 0x90080 的数据，这部分是由之前讲的 setup.s 程序将硬盘 1 的参数信息放在这里了，包括柱面数、磁头数、扇区数等信息。

```c
setup((void *) &drive_info);
```

### 根据机器系统数据设置硬盘参数

#### 进程1设置硬盘的hd_info

根据机器系统数据中的drive_info，如硬盘的柱面数，磁头数，扇区数，设置内核的hd_info。

![640](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\640.png)

```c
// kernel/blk_drv.c

struct hd_i_struct {
    // 磁头数、每磁道扇区数、柱面数、写前预补偿柱面号、磁头着陆区柱面号、控制字节
    int head,sect,cyl,wpcom,lzone,ctl;
};
struct hd_i_struct hd_info[] = {};

int sys_setup(void * BIOS) {
    hd_info[0].cyl = *(unsigned short *) BIOS;
    hd_info[0].head = *(unsigned char *) (2+BIOS);
    hd_info[0].wpcom = *(unsigned short *) (5+BIOS);
    hd_info[0].ctl = *(unsigned char *) (8+BIOS);
    hd_info[0].lzone = *(unsigned short *) (12+BIOS);
    hd_info[0].sect = *(unsigned char *) (14+BIOS);
    BIOS += 16;
    ...
}
```

然后是硬盘分区表的设置

```c
static struct hd_struct {
    long start_sect;
    long nr_sects;
} hd[5] = {}

int sys_setup(void * BIOS) {
    ...
    hd[0].start_sect = 0;
    hd[0].nr_sects = 
        hd_info[0].head * hd_info[0].sect * hd_info[0].cyl;
    struct buffer_head *bh = bread(0x300, 0);
    struct partition *p = 0x1BE + (void *)bh->b_data;
    for (int i=1;i<5;i++,p++) {
        hd[i].start_sect = p->start_sect;
        hd[i].nr_sects = p->nr_sects;
    }
    brelse(bh);
    ...
}
```

![640 (1)](E:\计算机系统学习\操作系统\Linux内核设计的艺术\images\640 (1).png)

这表示硬盘的分区信息，每个分区用 **start_sect** 和 **nr_sects**，也就是开始扇区和总扇区数来记录。这些信息是从哪里获取的呢？就是在硬盘的第一个扇区的 0x1BE 偏移处，这里存储着该硬盘的分区信息，只要把这个地方的数据拿到就 OK 了。所以 bread 就是干这事的，从硬盘读取数据。

#### 读取硬盘引导块到缓冲区

硬盘最基础的信息就是分区表，其它信息都可以从这个信息引导出来，这个信息所在的块就是引导块。一块硬盘只有唯一的一个引导块，即硬盘的0号逻辑块。引导块有两个扇区，真正有用的是第一个扇区。我们设定计算机只有一块硬盘。下面把硬盘的引导块读入缓冲区，以便后续程序解读引导块中的信息。这个工作通过调用bread()函数实现，bread()可以理解为block read。

```c
// 第一个物理盘的设备号是0x300，第二个是0x305，读取每个物理硬盘的0号块，即引导块
for (drive=0 ; drive<NR_HD ; drive++) {
		if (!(bh = bread(0x300 + drive*5,0))) {
			printk("Unable to read partition table of drive %d\n\r",
				drive);
			panic("");
		}
    ...
}
```

整个函数的执行过程为：bread()-->getblk()-->get_hash_table()-->find_buffer()。进入bread()函数后，先调用getblk()函数在缓冲区中申请一个空闲的缓冲块；在getblk()函数中，先调用get_hash_table()函数查找哈希表；进入get_hash_table()函数后，调用find_buffer()函数查找缓冲区中是否有指定设备号，块号的缓冲块。部分函数在缓冲区结构初始化的时候已经介绍过了。

```c
#define _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)
#define hash(dev,block) hash_table[_hashfn(dev,block)]

static struct buffer_head * find_buffer(int dev, int block)
{		
	struct buffer_head * tmp;

	for (tmp = hash(dev,block) ; tmp != NULL ; tmp = tmp->b_next)
		if (tmp->b_dev==dev && tmp->b_blocknr==block)
			return tmp;
	return NULL;
}
```

对于find_buffer()函数来说，从对应设备号以及块号所确定的hash位置处开始查找。当前是第一次使用缓冲区，缓冲区中不存在已读入的缓冲块，find_buffer()返回的是NULL。从find_buffer()，get_hash_table()函数退出后，返回getblk()函数，在空闲表中申请一个新的空闲缓冲块，也就是从free_list所指向的缓冲块开始寻找一个新的空闲缓冲块。

```c
#define BADNESS(bh) (((bh)->b_dirt<<1)+(bh)->b_lock)
struct buffer_head * getblk(int dev,int block)
{
	struct buffer_head * tmp, * bh;

repeat:
	if (bh = get_hash_table(dev,block))
		return bh;
	tmp = free_list;
	do {
		if (tmp->b_count)
			continue;
		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
			bh = tmp;
			if (!BADNESS(tmp))
				break;
		}
/* and repeat until we find something good */
	} while ((tmp = tmp->b_next_free) != free_list);
    // 若没有获得空闲缓冲块，则休眠
	if (!bh) {
		sleep_on(&buffer_wait);
		goto repeat;
	}
    // 若空闲缓冲块被锁住了，那么一直休眠
	wait_on_buffer(bh);
	if (bh->b_count)
		goto repeat;
	while (bh->b_dirt) {
		sync_dev(bh->b_dev);
		wait_on_buffer(bh);
		if (bh->b_count)
			goto repeat;
	}
/* NOTE!! While we slept waiting for this block, somebody else might */
/* already have added "this" block to the cache. check it */
	if (find_buffer(dev,block))
		goto repeat;
/* OK, FINALLY we know that this buffer is the only one of it's kind, */
/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
	bh->b_count=1;
	bh->b_dirt=0;
	bh->b_uptodate=0;
	remove_from_queues(bh);
	bh->b_dev=dev;
	bh->b_blocknr=block;
	insert_into_queues(bh);
	return bh;
}
```

最后一段代码是对空闲缓冲块的初始化，关键是两个函数的调用，`remove_from_queues(bh)`，`insert_into_queues`，先将对应缓冲块从链表中删除然后再插入，这是因为我们的循环链表不是一个静态的，从free_list所指缓冲块开始，最近使用的程度逐渐加大。故当前这个缓冲块应该放在最后也就是free_list之前的位置。

```c
#define _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)
#define hash(dev,block) hash_table[_hashfn(dev,block)]

static inline void remove_from_queues(struct buffer_head * bh)
{
/* remove from hash-queue */
	if (bh->b_next)
		bh->b_next->b_prev = bh->b_prev;
	if (bh->b_prev)
		bh->b_prev->b_next = bh->b_next;
	if (hash(bh->b_dev,bh->b_blocknr) == bh)
		hash(bh->b_dev,bh->b_blocknr) = bh->b_next;
/* remove from free list */
	if (!(bh->b_prev_free) || !(bh->b_next_free))
		panic("Free block list corrupted");
	bh->b_prev_free->b_next_free = bh->b_next_free;
	bh->b_next_free->b_prev_free = bh->b_prev_free;
	if (free_list == bh)
		free_list = bh->b_next_free;
}

static inline void insert_into_queues(struct buffer_head * bh)
{
/* put at end of free list */
	bh->b_next_free = free_list;
	bh->b_prev_free = free_list->b_prev_free;
	free_list->b_prev_free->b_next_free = bh;
	free_list->b_prev_free = bh;
/* put the buffer in new hash-queue if it has a device */
	bh->b_prev = NULL;
	bh->b_next = NULL;
	if (!bh->b_dev)
		return;
	bh->b_next = hash(bh->b_dev,bh->b_blocknr);
    // 挂接hash_table
	hash(bh->b_dev,bh->b_blocknr) = bh;
	bh->b_next->b_prev = bh;
}
```

执行完getblk()函数后，返回bread()函数。

#### 将找到的缓冲块与请求项挂接

返回bread()函数后，调用ll_rw_block()这个函数。

```c
struct buffer_head * bread(int dev,int block)
{
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))
		panic("bread: getblk returned NULL\n");
	if (bh->b_uptodate)
		return bh;
	ll_rw_block(READ,bh);
	wait_on_buffer(bh);
	if (bh->b_uptodate)
		return bh;
	brelse(bh);
	return NULL;
}
```

进入ll_rw_block()函数后，先判断缓冲块对应的设备是否存在或这个设备的请求项函数是否挂接正常。若存在且正常，说明可以操作这个缓冲块，调用make_request()函数，准备将缓冲块与请求项建立关系。

```c
void ll_rw_block(int rw, struct buffer_head * bh)
{
	unsigned int major;

	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
	!(blk_dev[major].request_fn)) {
		printk("Trying to read nonexistent block-device\n\r");
		return;
	}
	make_request(major,rw,bh);
}
```

要想搞清楚`ll_rw_block()`函数就需要先对blk.h文件进行解读

```c
#ifdef MAJOR_NR

/*
 * Add entries as needed. Currently the only block devices
 * supported are hard-disks and floppies.
 */

#if (MAJOR_NR == 1)
/* ram disk */
#define DEVICE_NAME "ramdisk"
#define DEVICE_REQUEST do_rd_request
#define DEVICE_NR(device) ((device) & 7)
#define DEVICE_ON(device) 
#define DEVICE_OFF(device)

#elif (MAJOR_NR == 2)
/* floppy */
#define DEVICE_NAME "floppy"
#define DEVICE_INTR do_floppy
#define DEVICE_REQUEST do_fd_request
#define DEVICE_NR(device) ((device) & 3)
#define DEVICE_ON(device) floppy_on(DEVICE_NR(device))
#define DEVICE_OFF(device) floppy_off(DEVICE_NR(device))

#elif (MAJOR_NR == 3)
/* harddisk */
#define DEVICE_NAME "harddisk"
#define DEVICE_INTR do_hd
#define DEVICE_REQUEST do_hd_request
#define DEVICE_NR(device) (MINOR(device)/5)
#define DEVICE_ON(device)
#define DEVICE_OFF(device)

#elif
/* unknown blk device */
#error "unknown blk device"

#endif
```

上面这一大段预编译指令尤为重要，同时也极其精妙。

我们进入hd.c文件中去看（因为我们当前在操作硬盘）

```c
#define MAJOR_NR 3
#include "blk.h"
```

当我们对MAJOR_NR预编译之后将blk.h头文件include进来，上面那一大段预编译指令就起作用了，因为这里的预编译MAJOR_NR为3，所以会执行下面的预编译指令

```c
#elif (MAJOR_NR == 3)
/* harddisk */
#define DEVICE_NAME "harddisk"
#define DEVICE_INTR do_hd
#define DEVICE_REQUEST do_hd_request
#define DEVICE_NR(device) (MINOR(device)/5)
#define DEVICE_ON(device)
#define DEVICE_OFF(device)
```

在这里定义了设备名称，设备请求项服务程序等等，其中设备请求项服务程序尤为关键

`#define DEVICE_REQUEST do_hd_request`，在hd_init()函数中就用到了这个，将这个设备请求项服务程序进行挂接。这样做的巧妙之处在于所有设备的初始化及一些其它操作都是相同的代码逻辑。

```c
// hd.c
void hd_init(void)
{
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
	set_intr_gate(0x2E,&hd_interrupt);
	outb_p(inb_p(0x21)&0xfb,0x21);
	outb(inb_p(0xA1)&0xbf,0xA1);
}

// floppy.c
void floppy_init(void)
{
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
	set_trap_gate(0x26,&floppy_interrupt);
	outb(inb_p(0x21)&~0x40,0x21);
}
```

为了更深入的理解，对于blk_dev的声明如下：可以明显的看出下标索引为3的位置就是硬盘。

```c
// blk.h
struct blk_dev_struct {
	void (*request_fn)(void);
	struct request * current_request;
};

// ll_rw_blk.c
struct blk_dev_struct blk_dev[NR_BLK_DEV] = {
	{ NULL, NULL },		/* no_dev */
	{ NULL, NULL },		/* dev mem */
	{ NULL, NULL },		/* dev fd */
	{ NULL, NULL },		/* dev hd */
	{ NULL, NULL },		/* dev ttyx */
	{ NULL, NULL },		/* dev tty */
	{ NULL, NULL }		/* dev lp */
};

```

从这里我们也可以看出Linux0.11整个项目的文件布局非常之合理，像对blk_dev的定义就放在了ll_rw_blk.c中，这个文件是对块的读写函数，所有设备一视同仁，放在这里最为恰当。

到这里，我们就能很清晰的解读ll_rw_block()函数了，有一个需要注意的是

```c
#define MAJOR(a) (((unsigned)(a))>>8)
```

这个宏是取设备的类型号，你像硬盘的设备号都是0x3xx，向右移动8位就是0x3也即是硬盘的类型号（也即blk_dev数组中的索引下标位置）

___

进程1继续执行，进入make_request()函数之后，先要将这个缓冲块加锁，目的是保护这个缓冲块在解锁之前将不再被任何进程操作。之后，在请求项结构中申请一个空闲请求项，准备与这个缓冲块相挂接。如果是读请求，则从整个请求结构的最末端开始寻找空闲请求项；如果是写请求，则从整个结构的2/3处。

```c
static inline void lock_buffer(struct buffer_head * bh)
{
	cli();
	while (bh->b_lock)
		sleep_on(&bh->b_wait);
	bh->b_lock=1;
	sti();
}

struct request request[NR_REQUEST];

static void make_request(int major,int rw, struct buffer_head * bh)
{
	struct request * req;
	int rw_ahead;

/* WRITEA/READA is special case - it is not really needed, so if the */
/* buffer is locked, we just forget about it, else it's a normal read */
	if (rw_ahead = (rw == READA || rw == WRITEA)) {
		if (bh->b_lock)
			return;
		if (rw == READA)
			rw = READ;
		else
			rw = WRITE;
	}
	if (rw!=READ && rw!=WRITE)
		panic("Bad block dev command, must be R/W/RA/WA");
	lock_buffer(bh);
	if ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {
		unlock_buffer(bh);
		return;
	}
repeat:
/* we don't allow the write-requests to fill up the queue completely:
 * we want some room for reads: they take precedence. The last third
 * of the requests are only for reads.
 */
	if (rw == READ)
		req = request+NR_REQUEST;
	else
		req = request+((NR_REQUEST*2)/3);
/* find an empty request */
	while (--req >= request)
		if (req->dev<0)
			break;
/* if none found, sleep on new requests: check for rw_ahead */
	if (req < request) {
		if (rw_ahead) {
			unlock_buffer(bh);
			return;
		}
		sleep_on(&wait_for_request);
		goto repeat;
	}
    
    // 上面所作的就是在request队列中找到一个合适的空闲请求项
/* fill up the request-info, and add it to the queue */
	req->dev = bh->b_dev;
	req->cmd = rw;
	req->errors=0;
	req->sector = bh->b_blocknr<<1;// 一个block两个sector
	req->nr_sectors = 2;
	req->buffer = bh->b_data;
	req->waiting = NULL;
	req->bh = bh;
	req->next = NULL;
	add_request(major+blk_dev,req);
}
```

调用add_request()函数，向请求队列中加载该请求项，进入add_request()后，先对当前硬盘的工作情况进行分析，然后设置该请求项为当前请求项，并调用硬盘请求项处理函数				(dev->request_fn)，即do_hd_request()函数（hd_init()中设置的）去给硬盘发送读硬盘命令。

```c
// kernel.blk_dev/ll_rw_block.c
static void add_request(struct blk_dev_struct * dev, struct request * req)
{
	struct request * tmp;

	req->next = NULL;
	cli();
	if (req->bh)
		req->bh->b_dirt = 0;
	if (!(tmp = dev->current_request)) {
        // 当前设备没有请求
		dev->current_request = req;
		sti();
		(dev->request_fn)(); // do_hd_request()
		return;
	}
    // 电梯算法：目的是让磁盘磁头的移动距离最小
	for ( ; tmp->next ; tmp=tmp->next)
		if ((IN_ORDER(tmp,req) ||
		    !IN_ORDER(tmp,tmp->next)) &&
		    IN_ORDER(req,tmp->next))
			break;
	req->next=tmp->next;
	tmp->next=req;
	sti();
}
```

#### 读硬盘



```c
void do_hd_request(void)
{
	int i,r;
	unsigned int block,dev;
	unsigned int sec,head,cyl;
	unsigned int nsect;

	INIT_REQUEST;
	dev = MINOR(CURRENT->dev);
	block = CURRENT->sector;
	if (dev >= 5*NR_HD || block+2 > hd[dev].nr_sects) {
		end_request(0);
		goto repeat;
	}
	block += hd[dev].start_sect;
	dev /= 5;
	__asm__("divl %4":"=a" (block),"=d" (sec):"0" (block),"1" (0),
		"r" (hd_info[dev].sect));
	__asm__("divl %4":"=a" (cyl),"=d" (head):"0" (block),"1" (0),
		"r" (hd_info[dev].head));
	sec++;
	nsect = CURRENT->nr_sectors;
	if (reset) {
		reset = 0;
		recalibrate = 1;
		reset_hd(CURRENT_DEV);
		return;
	}
	if (recalibrate) {
		recalibrate = 0;
		hd_out(dev,hd_info[CURRENT_DEV].sect,0,0,0,
			WIN_RESTORE,&recal_intr);
		return;
	}	
	if (CURRENT->cmd == WRITE) {
		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&write_intr);
		for(i=0 ; i<3000 && !(r=inb_p(HD_STATUS)&DRQ_STAT) ; i++)
			/* nothing */ ;
		if (!r) {
			bad_rw_intr();
			goto repeat;
		}
		port_write(HD_DATA,CURRENT->buffer,256);
	} else if (CURRENT->cmd == READ) {
		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);
	} else
		panic("unknown hd-command");
}
```

